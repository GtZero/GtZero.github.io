<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一直疑惑的Unicode字符集</title>
    <url>/2020/02/18/Unicode%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="记录九-Unicode字符集"><a href="#记录九-Unicode字符集" class="headerlink" title="记录九. Unicode字符集"></a>记录九. Unicode字符集</h1><p>[TOC]</p>
<blockquote>
<p><a href="https://xiaogd.net/category/%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bc%96%e7%a0%81%e4%b8%8e%e4%b9%b1%e7%a0%81/page/4/" target="_blank" rel="noopener">参考1</a><br><a href="https://blog.csdn.net/qweewqpkn/article/details/50194441" target="_blank" rel="noopener">参考2</a></p>
</blockquote>
<h2 id="一-字符集与编码"><a href="#一-字符集与编码" class="headerlink" title="一. 字符集与编码"></a>一. 字符集与编码</h2><p><strong>严格意义上: 两个不同层面的概念</strong><br><a id="more"></a></p>
<ul>
<li>charset 是 character set 的简写，即<strong>字符集</strong>。完成字符到数字的对应</li>
<li>encoding 是 charset encoding 的简写，即<strong>字符集编码</strong>，简称<strong>编码</strong>。完成数字到具体的二进制编码</li>
</ul>
<blockquote>
<p>如果数字到具体的二进制编码，形式只有一种。即字符集与编码为一对一情形，则混为一谈，也都清楚是一个东西</p>
</blockquote>
<h2 id="二-Unicode与UTF编码-Unicode-Transformation-Format"><a href="#二-Unicode与UTF编码-Unicode-Transformation-Format" class="headerlink" title="二. Unicode与UTF编码(Unicode Transformation Format)"></a>二. Unicode与UTF编码(Unicode Transformation Format)</h2><blockquote>
<p>Unicode字符集，UTF-8 -16 -32 是同一种字符集的不同编码实现</p>
</blockquote>
<h3 id="1-Unicode-整个编码过程"><a href="#1-Unicode-整个编码过程" class="headerlink" title="1. Unicode 整个编码过程"></a>1. Unicode 整个编码过程</h3><p><strong>存在的两个层面</strong>: 字符 –&gt; 码点 –&gt; 具体编码(即具体的二进制数)<br><img src="\cttImages\image-20200307163046170.png" alt="image-20200307163046170" style="zoom:80%;"></p>
<h3 id="2-涉及的概念"><a href="#2-涉及的概念" class="headerlink" title="2. 涉及的概念"></a>2. 涉及的概念</h3><h4 id="2-1-码点"><a href="#2-1-码点" class="headerlink" title="2.1. 码点"></a>2.1. 码点</h4><p><strong>1. 简单说明</strong>: 码点是一种抽象的数学编号</p>
<p><strong>2. 码点的表示形式与范围</strong></p>
<ul>
<li>U+[XX]XXXX 是码点的表示形式，X 代表一个十六制数字，可以有 4-6 位，不足 4 位前补 0 补足 4 位，超过则按是几位就是几位</li>
<li>它的范围目前是 U+0000 ~ U+10FFFF，理论大小为 10FFFF+1=110000(十六进制)，而FFFF + 1 = 10000，为65536个数，则总范围为 (16 + 1) * 65536 粗略等于 102万</li>
<li>按Unicode官方说法，码点范围就这些，以后也不会再扩充</li>
</ul>
<p><strong>3. 平面</strong>: 将前面的17 * 65536大小的部分，每个65536分为一个字符平面，编号从0开始<br><img src="\cttImages\image-20200307163122697.png" alt="image-20200307163122697" style="zoom:70%;"></p>
<ul>
<li>第一个平面称为<strong>BMP (Basic Multilingual Plane 基本多语言平面)</strong> ，也叫plane 0。码点范围在U+0000 ~ U+FFFF，日常使用的字符绝大多数都落在这个平面</li>
<li>其余十六个平面称为<strong>SP(Supplementary Planes) 增补平面</strong></li>
</ul>
<blockquote>
<p>在第一个平面BMP中的字符，使用两个字节即可表示。我们的汉字在<strong>CJK统一汉字区域(CJK：Chinese, Japanese, and Korean，中日韩)</strong> </p>
</blockquote>
<p><strong>4. BMP鸟瞰图</strong>: 引出代理区概念<br><img src="\cttImages\image-20200307163153312.png" alt="image-20200307163153312" style="zoom:80%;"></p>
<p><strong>5. 代理区(Surrogate Area)</strong>: 在鸟瞰图的空白部分属于代理区<br><img src="\cttImages\image-20200307163211428.png" alt="image-20200307163211428" style="zoom:80%;"></p>
<ul>
<li>红色部分 D800–DBFF 属于高代理区(High Surrogate Area)</li>
<li>蓝色部分 DC00–DFFF 属于低代理区(Low Surrogate Area)</li>
<li>各自的大小均为 4×256=1024</li>
<li>这两个区域构成一个二维的表格，供1024 <em> 1024 = 16 </em> 65536，恰好表示16个增补平面的所有字符</li>
<li>代理区的作用见下面 UTF-16 (构成代理对)</li>
</ul>
<p><img src="\cttImages\image-20200307163239577.png" alt="image-20200307163239577" style="zoom:80%;"> </p>
<h4 id="2-2-UTF-8-16-32-具体编码"><a href="#2-2-UTF-8-16-32-具体编码" class="headerlink" title="2.2. UTF-8 -16 -32 具体编码"></a>2.2. UTF-8 -16 -32 具体编码</h4><blockquote>
<p>第一版Unicode统一使用二字节编码，对ASCII 的字符多占一字符。据说是大牛倒腾除了UTF-8，来兼容</p>
</blockquote>
<p><strong>1. utf-8</strong></p>
<ul>
<li>变长的编码格式，可兼容ASCII。因为能兼容，所以国际广受欢迎</li>
<li>由于是变长格式，为了在解析时不发生歧义，使用了高位作区分，so 在保存中文方面效率不算太好，GBK类的效率会更高，但国际上扩展空间不如 utf-8</li>
<li><a href="https://xiaogd.net/%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%8e%e7%bc%96%e7%a0%81%ef%bc%88%e5%9b%9b%ef%bc%89-unicode/#Unicode%20%E4%B8%AD%E7%9A%84%E7%A0%81%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" target="_blank" rel="noopener">码点转成编码的规则</a></li>
</ul>
<p><img src="\cttImages\image-20200307163323239.png" alt="image-20200307163323239" style="zoom:67%;"> </p>
<p><strong>2. utf-16</strong></p>
<ul>
<li>可两字节or四字节</li>
<li>当字符的码点处于BMP内，则使用两字节</li>
<li>其余字符，则使用4字节的代理对来编码</li>
<li>由于早期第一版的Unicode的使用，这里utf-16也有一定范围的应用</li>
</ul>
<p><strong>3. utf-32</strong></p>
<ul>
<li>使用四字节表示，占用空间多，使用不广泛</li>
<li><a href="https://www.jianshu.com/p/de309b73caf3" target="_blank" rel="noopener">Unicode码点最长就24位(3字节)，UTF-32给了4字节给了字符集非常大的扩展空间</a>, 这篇文章有描述</li>
</ul>
<p><strong>在增补平面的码点，到UTF-16四字节的转换</strong>: 使用代理对</p>
<ul>
<li>一个高代理区的行 加 一个低代理区的列 的编码即是一个代理对<br><img src="\cttImages\image-20200307163357781.png" alt="image-20200307163357781" style="zoom:80%;"></li>
<li>增补平面的字符，对应的码元，会转成四字节的一对代码对</li>
</ul>
<h3 id="3-其他相关概念"><a href="#3-其他相关概念" class="headerlink" title="3. 其他相关概念"></a>3. 其他相关概念</h3><ul>
<li>UCS-2 (Universal Character Set coded in 2 octets)，表示码点与编码字节数之间的关系</li>
<li>UCS-4</li>
</ul>
<p><strong>字符集的发展历史</strong></p>
<ul>
<li>美国标准ASCII。1字节，0 ~ 127个数 128个字符</li>
<li>由于1字节，还有1位可用。在兼容ASCII基础上，出现了OEM字符集(Original Equipment Manufacturer<br>原始设备制造商)，即不同供应商可能有不同字符集，出现了ISO8859-1 -3 等</li>
<li>中文编码GB2312，兼容ASCII。GBK是对GB2312的扩展</li>
<li>出现Unicode</li>
</ul>
<h3 id="4-语言相关-Java"><a href="#4-语言相关-Java" class="headerlink" title="4. 语言相关 Java"></a>4. 语言相关 Java</h3><p><strong>十六进制数的表示</strong></p>
<ul>
<li>整形表示十六进制数为0x开头</li>
<li>字符表示十六进制数以 \u 开头。u为unicode</li>
</ul>
<p><strong>char、String类型</strong></p>
<ul>
<li>char采用了UTF-16的格式，对于超过BMP的字符保存时，会发生异常</li>
<li>String类型是用char保存字符，<strong><a href="https://www.jianshu.com/p/957b249a02d8" target="_blank" rel="noopener">Java内部使用UTF-16作为内部编码方式</a></strong></li>
</ul>
<p><strong><a href="https://blog.csdn.net/u010297957/article/details/48495791" target="_blank" rel="noopener">证明char编码的代码</a></strong><br><img src="\cttImages\image-20200307163446428.png" alt="image-20200307163446428" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>源码分析 JDK Future模式分析</title>
    <url>/2019/11/21/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20JDK%20Future%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="源码分析-JDK-Future模式分析"><a href="#源码分析-JDK-Future模式分析" class="headerlink" title="源码分析: JDK Future模式分析"></a>源码分析: JDK Future模式分析</h1><p>[TOC]</p>
<h2 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一.基本概念"></a>一.基本概念</h2><p><strong>基本方法接口</strong></p>
<ol>
<li>Executor接口:<br>void execute(Runnable command)方法。开启一个线程执行任务，无返回值</li>
<li>ExecutorService接口:<br>继承自Executor接口，里面的submit方法，最终会开启一个线程执行任务，并返回Future对象，该对象中含有该线程的返回值</li>
<li>Callable接口可用于创建线程，call方法会有返回值且可抛出异常</li>
</ol>
<a id="more"></a>
<p><strong>基本示意图</strong><br><img src="\cttImages\1573998581653.png" alt="1573998581653"></p>
<h2 id="二-源码分析"><a href="#二-源码分析" class="headerlink" title="二.源码分析"></a>二.源码分析</h2><p><u><strong>线程通过submit提交，该线程的返回值是怎么放到Future中的?</strong></u></p>
<p><strong>1. submit源码 — 摘自ExecutorService的实现类AbstractExecutorService(子类有ThreadPoolExecutor)</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>都调用了newTaskFor方法，task任务作为参数传入。使用前面提到的execute执行开启一个新的线程，<strong>直接返回newTaskFor方法返回的RunnableFuture</strong></p>
<blockquote>
<p>通过Future接口的get方法，可以获得真实数据。如果没有则阻塞，有则取出。看状态，第五步分析</p>
</blockquote>
<p><strong>2. newTaskFor方法</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里都调用了FutureTask的不同参数的构造方法。即每个newTaskFor方法得到的RunnableFuture接口的类型为FutureTask实现类</p>
<p><strong>3. FutureTask的构造方法</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>FutureTask中含有Callable类型的属性</li>
<li>以Runnable接口为参数的构造方法，调用了callable方法。该方法源码已贴，即使用了适配器模式，将Runnable接口适配成Callable接口类型(即call方法调用run，且无返回值)。放入到FutureTask的Callable属性</li>
<li>以Callable接口为参数的构造方法，直接放入到FutureTask的Callable属性</li>
</ul>
<p><strong>4. FutureTask的run方法。看完1-3，此时构造FutureTask完毕(即封装原始task完毕)，开始调用executor方法，以FutureTask作为任务参数，开启新线程执行其中的run方法</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中调用call方法即执行了原始的任务。其他代码即是封装处理的部分，将返回的参数信息放到Future的result中</p>
<p><strong>5. Future的get方法。获得真实数据</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        Object x = outcome;</span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>源码分析 mybatis SQL执行流程及参数绑定过程</title>
    <url>/2019/08/27/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20mybatis%20SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>持久层框架封装了jdbc的底层代码，我们需要提供的即sql、映射规则、pojo<br>研究mybatis，即</p>
<ol>
<li>mybatis怎么读取配置文件创建SqlSessionFactory</li>
<li>SqlSession运行过程</li>
</ol>
</blockquote>
<p><strong>这里更多探究的是SqlSession运行过程</strong></p>
<a id="more"></a>
<h1 id="第一点-mybatis-源码分析–sql大致执行流程"><a href="#第一点-mybatis-源码分析–sql大致执行流程" class="headerlink" title="第一点 - mybatis 源码分析–sql大致执行流程"></a>第一点 - mybatis 源码分析–sql大致执行流程</h1><p>[TOC]</p>
<h2 id="一-准备"><a href="#一-准备" class="headerlink" title="一.准备"></a>一.准备</h2><h3 id="1-映射器组成"><a href="#1-映射器组成" class="headerlink" title="1. 映射器组成"></a>1. 映射器组成</h3><ul>
<li>MappedStatement，用于保存映射器的一个节点(select|insert|delete|update),包括许多配置的sql、sql的id，缓存信息等</li>
<li>SqlSource，提供BoundSql对象，是MappedStatement的属性。负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</li>
<li><p>BoundSql，表示动态生成的SQL语句以及相应的参数信息。常用属性:SQL、parameterObject、parameterMappings</p>
<ul>
<li><p>parameterObject为传入的参数本身</p>
</li>
<li><p>parameterMappings，它是一个List，装parameterMapping对象，包括参数属性，名称，表达式，javaType，jdbcType、typeHandler等信息</p>
</li>
<li><p>sql，既是写在映射器中的一条SQL</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-SqlSession四大对象"><a href="#2-SqlSession四大对象" class="headerlink" title="2.SqlSession四大对象"></a>2.SqlSession四大对象</h3><p>Mapper执行过程是通过Executor、StatementHandler、ParameterHandler、ResultHandler来完成数据库操作和结果返回的</p>
<ul>
<li>Executor 执行器，调度StatementHandler、ParameterHandler、ResultHandler等来执行对应SQL</li>
<li>StatementHandler 数据库会话器，使用数据库的Statement、PreparedStatement执行操作，核心</li>
<li>ParameterHandler 参数处理器，用于SQL对参数的处理</li>
<li>ResultHandler 结果处理器，对数据集的封装返回</li>
</ul>
<h2 id="二-SqlSession运行过程"><a href="#二-SqlSession运行过程" class="headerlink" title="二.SqlSession运行过程"></a>二.SqlSession运行过程</h2><p><strong>SqlSession用途</strong></p>
<ol>
<li>获取映射器</li>
<li>直接通过命名信息去执行SQL返回结果<br> 推荐使用映射器+xml方式<h3 id="1-映射器动态代理对象执行过程"><a href="#1-映射器动态代理对象执行过程" class="headerlink" title="1. 映射器动态代理对象执行过程"></a>1. 映射器动态代理对象执行过程</h3>调用SqlSession中的getMapper方法，传入类对象。会通过类对象获得对应的MapperProxyFactory，构建实例，动态代理MapperProxy为通知类。生成动态代理对象，代理方法放到MapperProxy中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isDefaultMethod(method)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.invokeDefaultMethod(proxy, method, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MapperMethod mapperMethod = <span class="keyword">this</span>.cachedMapperMethod(method);</span><br><span class="line">        <span class="keyword">return</span> mapperMethod.execute(<span class="keyword">this</span>.sqlSession, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>判断，如果是接口，则调用下面的方法，判断如果是默认的方法，如toString等方法，则直接调用。生成MapperMethod方法对象，执行该对象的execute方法传入sqlSession和当前参数，在该execute中进行具体的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">        Object param;</span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">switch</span>(<span class="keyword">this</span>.command.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> SELECT:</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsVoid() &amp;&amp; <span class="keyword">this</span>.method.hasResultHandler()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.executeWithResultHandler(sqlSession, args);</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsMany()) &#123;</span><br><span class="line">                result = <span class="keyword">this</span>.executeForMany(sqlSession, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsMap()) &#123;</span><br><span class="line">                result = <span class="keyword">this</span>.executeForMap(sqlSession, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.method.returnsCursor()) &#123;</span><br><span class="line">                result = <span class="keyword">this</span>.executeForCursor(sqlSession, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">                result = sqlSession.selectOne(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="comment">//抛错</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + <span class="keyword">this</span>.command.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//抛错</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.method.getReturnType().isPrimitive() &amp;&amp; !<span class="keyword">this</span>.method.returnsVoid()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + <span class="keyword">this</span>.command.getName() + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + <span class="keyword">this</span>.method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result;<span class="comment">//返回sql的执行结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>MappedStatement有SqlCommandType属性(存是select/insert等类型)，在MappedMethod构造时，SqlCommandType放进MappedMethod内部的SqlCommand中的type(xml中的标签类型)来判断执行那一段方法，如为查询语句时即SELECT，根据返回类型来判断具体执行哪个方法<br><strong>举例:执行查询语句，调用到executeForMany方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperMethod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MapperMethod.SqlCommand command;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MapperMethod.MethodSignature method;</span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">        Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        List result;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.method.hasRowBounds()) &#123;</span><br><span class="line">            RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</span><br><span class="line">            result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.method.getReturnType().isArray() ? <span class="keyword">this</span>.convertToArray(result) : <span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最后通过SqlSession调用</strong> ，通过MapperMethod的SqlCommand属性调用getName方法获得接口名+方法名的调用，探究的关键就在于MapperMethod在创建的时候就在SqlCommand的name中初始化好了名称，具体实现如下，看MapperProxy的invoke中的MapperMethod mapperMethod = this.cachedMapperMethod(method);<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        MapperMethod mapperMethod = (MapperMethod)<span class="keyword">this</span>.methodCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mapperMethod = <span class="keyword">new</span> MapperMethod(<span class="keyword">this</span>.mapperInterface, method, <span class="keyword">this</span>.sqlSession.getConfiguration());</span><br><span class="line">            <span class="keyword">this</span>.methodCache.put(method, mapperMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mapperMethod;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//MapperMethod的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = <span class="keyword">new</span> MapperMethod.SqlCommand(config, mapperInterface, method);</span><br><span class="line">        <span class="keyword">this</span>.method = <span class="keyword">new</span> MapperMethod.MethodSignature(config, mapperInterface, method);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//SqlCommand的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line">            String methodName = method.getName();</span><br><span class="line">            Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">            MappedStatement ms = <span class="keyword">this</span>.resolveMappedStatement(mapperInterface, methodName, declaringClass, configuration);</span><br><span class="line">            <span class="keyword">if</span> (ms == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getAnnotation(Flush<span class="class">.<span class="keyword">class</span>) </span>== <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Invalid bound statement (not found): "</span> + mapperInterface.getName() + <span class="string">"."</span> + methodName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.name = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.type = SqlCommandType.FLUSH;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.name = ms.getId();<span class="comment">//这里将MappedStatement中的id属性进行赋值给name：接口名+方法名</span></span><br><span class="line">                <span class="keyword">this</span>.type = ms.getSqlCommandType();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>MapperMethod的内部类MethodSignature，主要作用是对Method方法做一步封装，比如: 提供判断方法返回值是否为NULL或Map等方法，及提供处理接口传入参数，封装转换成SqlSession所要的参数</p>
<p>在SqlCommand中，两个存放的信息，name 负责存放调用的目标方法名  ，type 负责存放SQL语句的类型（SELECT|INSERT|UPDATE等）。</p>
<p>通过SqlCommand构造函数可以看到，<code>this.name = ms.getId();</code>其对name进行了赋值，值为对应xml文件中对应方法的id，怎么找到的这个MappedStatement的?<br>看这行代码<code>MappedStatement ms = this.resolveMappedStatement(mapperInterface, methodName, declaringClass, configuration);</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MappedStatement <span class="title">resolveMappedStatement</span><span class="params">(Class&lt;?&gt; mapperInterface, String methodName, Class&lt;?&gt; declaringClass, Configuration configuration)</span> </span>&#123;</span><br><span class="line">            String statementId = mapperInterface.getName() + <span class="string">"."</span> + methodName;</span><br><span class="line">            <span class="keyword">if</span> (configuration.hasStatement(statementId)) &#123;</span><br><span class="line">                <span class="keyword">return</span> configuration.getMappedStatement(statementId);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mapperInterface.equals(declaringClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Class[] var6 = mapperInterface.getInterfaces();</span><br><span class="line">                <span class="keyword">int</span> var7 = var6.length;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var8 = <span class="number">0</span>; var8 &lt; var7; ++var8) &#123;</span><br><span class="line">                    Class&lt;?&gt; superInterface = var6[var8];</span><br><span class="line">                    <span class="keyword">if</span> (declaringClass.isAssignableFrom(superInterface)) &#123;</span><br><span class="line">                        MappedStatement ms = <span class="keyword">this</span>.resolveMappedStatement(superInterface, methodName, declaringClass, configuration);</span><br><span class="line">                        <span class="keyword">if</span> (ms != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> ms;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，mybaits将调用的接口名与方法名的字符串，在MappedStatements中找对应的xml中对应的MappedStatement结点，从而调用到对应的xml写的sql。(MappedStatements是Configuration的一个属性<code>protected final Map&lt;String, MappedStatement&gt; mappedStatements;</code>)</p>
<h3 id="2-底层执行过程"><a href="#2-底层执行过程" class="headerlink" title="2. 底层执行过程"></a>2. 底层执行过程</h3><p>在创建SqlSession时，已经创建了Executor<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.openSessionFromDataSource(<span class="keyword">this</span>.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>具体的创建方法如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">        executorType = executorType == <span class="keyword">null</span> ? <span class="keyword">this</span>.defaultExecutorType : executorType;</span><br><span class="line">        executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">        Object executor;</span><br><span class="line">        <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cacheEnabled) &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> CachingExecutor((Executor)executor);</span><br><span class="line">        &#125;</span><br><span class="line">        Executor executor = (Executor)<span class="keyword">this</span>.interceptorChain.pluginAll(executor);</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>已分析SimpleExecutor为例，上面我们看到调用映射器中的查询方法最终调用到SqlSession的查询selectList<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">        List var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MappedStatement ms = <span class="keyword">this</span>.configuration.getMappedStatement(statement);</span><br><span class="line">            var5 = <span class="keyword">this</span>.executor.query(ms, <span class="keyword">this</span>.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error querying database.  Cause: "</span> + var9, var9);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里获取该名字对应MappedStatement结点，执行executor的query方法，最终调用到真正的执行查询的方法doQuery<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        List var9;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Configuration configuration = ms.getConfiguration();</span><br><span class="line">            StatementHandler handler = configuration.newStatementHandler(<span class="keyword">this</span>.wrapper, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">            stmt = <span class="keyword">this</span>.prepareStatement(handler, ms.getStatementLog());</span><br><span class="line">            var9 = handler.query(stmt, resultHandler);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.closeStatement(stmt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var9;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，创建一个数据库会话器StatementHandler，执行StatementHandler的prepareStatement方法，进行初始化操作<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">this</span>.getConnection(statementLog);</span><br><span class="line">        Statement stmt = handler.prepare(connection, <span class="keyword">this</span>.transaction.getTimeout());</span><br><span class="line">        handler.parameterize(stmt);</span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//prepare方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection, Integer transactionTimeout)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ErrorContext.instance().sql(<span class="keyword">this</span>.boundSql.getSql());</span><br><span class="line">        Statement statement = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            statement = <span class="keyword">this</span>.instantiateStatement(connection);</span><br><span class="line">            <span class="keyword">this</span>.setStatementTimeout(statement, transactionTimeout);</span><br><span class="line">            <span class="keyword">this</span>.setFetchSize(statement);</span><br><span class="line">            <span class="keyword">return</span> statement;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException var5) &#123;</span><br><span class="line">            <span class="keyword">this</span>.closeStatement(statement);</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">            <span class="keyword">this</span>.closeStatement(statement);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Error preparing statement.  Cause: "</span> + var6, var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//parameterize方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parameterize</span><span class="params">(Statement statement)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parameterHandler.setParameters((PreparedStatement)statement);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>调用prepare方法设置最大行数、超时时间等基本操作，parameterize方法调用参数处理器绑定参数，执行StatementHandler的prepareStatement方法后调用，Executor的query方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        String sql = <span class="keyword">this</span>.boundSql.getSql();</span><br><span class="line">        statement.execute(sql);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.resultSetHandler.handleResultSets(statement);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>执行对应的语句，并调用结果处理器返回参数</p>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h2><p>在映射器+xml调用中</p>
<ol>
<li>获取映射器，getMapper通过动态代理，获得代理对象</li>
<li>在调用相关接口方法时，拦截调用相关方法，用接口名+方法名，在MapperStatements中查找对应的id的MapperStatement，有则，判断该id的xml片断的sql标签，调用sqlsession的对应方法，将接口名+方法名，参数传入</li>
<li>调用Executor的query/update方法，创建数据库会话器，调用prepare、parameterize(调用参数处理器绑定参数)，query/update(query需要返回封装结果，调用结果处理器。update中返回处理行数，直接返回int类型)</li>
</ol>
<h1 id="第二点-参数处理过程"><a href="#第二点-参数处理过程" class="headerlink" title="第二点 - 参数处理过程"></a>第二点 - 参数处理过程</h1><h2 id="一-完成参数索引与参数名之间的对应"><a href="#一-完成参数索引与参数名之间的对应" class="headerlink" title="一.完成参数索引与参数名之间的对应"></a>一.完成参数索引与参数名之间的对应</h2><p>在动态代理中，通过cachedMapperMethod创建MapperMethod，构建了MethodSignature对象，其中有一个属性为paramNameResolver<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        MapperMethod mapperMethod = (MapperMethod)<span class="keyword">this</span>.methodCache.get(method);</span><br><span class="line">        <span class="keyword">if</span> (mapperMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mapperMethod = <span class="keyword">new</span> MapperMethod(<span class="keyword">this</span>.mapperInterface, method, <span class="keyword">this</span>.sqlSession.getConfiguration());</span><br><span class="line">            <span class="keyword">this</span>.methodCache.put(method, mapperMethod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mapperMethod;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//MapperMethod的构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = <span class="keyword">new</span> MapperMethod.SqlCommand(config, mapperInterface, method);</span><br><span class="line">        <span class="keyword">this</span>.method = <span class="keyword">new</span> MapperMethod.MethodSignature(config, mapperInterface, method);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//MethodSignature初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MethodSignature</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line">            Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);</span><br><span class="line">            <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">                <span class="keyword">this</span>.returnType = (Class)resolvedReturnType;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">                <span class="keyword">this</span>.returnType = (Class)((ParameterizedType)resolvedReturnType).getRawType();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.returnType = method.getReturnType();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.returnsVoid = Void.TYPE.equals(<span class="keyword">this</span>.returnType);</span><br><span class="line">            <span class="keyword">this</span>.returnsMany = configuration.getObjectFactory().isCollection(<span class="keyword">this</span>.returnType) || <span class="keyword">this</span>.returnType.isArray();</span><br><span class="line">            <span class="keyword">this</span>.returnsCursor = Cursor<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">this</span>.<span class="title">returnType</span>)</span>;</span><br><span class="line">            <span class="keyword">this</span>.mapKey = <span class="keyword">this</span>.getMapKey(method);</span><br><span class="line">            <span class="keyword">this</span>.returnsMap = <span class="keyword">this</span>.mapKey != <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.rowBoundsIndex = <span class="keyword">this</span>.getUniqueParamIndex(method, RowBounds<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">this</span>.resultHandlerIndex = <span class="keyword">this</span>.getUniqueParamIndex(method, ResultHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">this</span>.paramNameResolver = <span class="keyword">new</span> ParamNameResolver(configuration, method);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>查看paramNameResolver初始化<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamNameResolver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GENERIC_NAME_PREFIX = <span class="string">"param"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; names;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasParamAnnotation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储目标方法的参数对应的Class对象</span></span><br><span class="line">        Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">        <span class="comment">//存储目标方法的注解对象数组,每一个方法的参数都有一个注解数组</span></span><br><span class="line">        Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">        SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        <span class="comment">//存储目标方法的参数个数</span></span><br><span class="line">        <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; ++paramIndex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">                String name = <span class="keyword">null</span>;</span><br><span class="line">                Annotation[] var9 = paramAnnotations[paramIndex];</span><br><span class="line">                <span class="keyword">int</span> var10 = var9.length;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                    Annotation annotation = var9[var11];</span><br><span class="line">                    <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.hasParamAnnotation = <span class="keyword">true</span>;</span><br><span class="line">                        name = ((Param)annotation).value();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (config.isUseActualParamName()) &#123;</span><br><span class="line">                        name = <span class="keyword">this</span>.getActualParamName(method, paramIndex);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        name = String.valueOf(map.size());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(paramIndex, name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>isSpecialParameter(paramTypes[paramIndex])判断是否是RowBounds和ResultHandler特殊类型。如果true,则跳过. </li>
<li>判断每一个注解是否是Param注解<ul>
<li>true,则hasParamAnnotation赋值为true,表示该方法有@Param注解,然后直接把Param注解的value值赋值给name </li>
<li>false，没有使用@Param注解,则判断是否配置中开启了useActualParamName<ul>
<li>true,则调用getActualParamName方法,并通过ParamNameUtil工具类获取目标方法的参数名,再把参数名存储到List中,接着根据传入的索引获取对应的参数名.然后把参数索引和参数名存放到map中.</li>
<li>false,那么就会使用参数索引作为name.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>当所有参数都判断之后,通过Collections.unmodifiableSortedMap(map)返回一个只读的Map容器赋值给names,同样存放着参数索引和    参数名的映射关系。此时MethodSignature初始化完毕</p>
<blockquote>
<p><strong>useActualParamName</strong>在<a href="https://www.cnblogs.com/yunqing/p/8065637.html" target="_blank" rel="noopener">3.4.1开始</a>可以配置true|false。<a href="https://blog.csdn.net/qq_33468239/article/details/72810058" target="_blank" rel="noopener">3.4.2之前为false。之后为true</a></p>
<p>例子：<strong>这是在多个参数的时候，才会封装成map，return map。如果只有一个参数则直接返回该参数</strong><img src="\cttImages\image-20191226201723181.png" alt="image-20191226201723181" style="zoom:67%;"><br><code>Employee findByIdAndNameWithGender(Integer id, @Param(&quot;myName&quot;)String name, String gender);</code></p>
<ul>
<li>当useActualParamName()为false时:<img src="\cttImages\image-20191226191357174.png"><br>0 -&gt; “0”<br>1 -&gt; “myName”<br>2 -&gt; “2”  <img src="\cttImages\image-20191226191322397.png"> </li>
<li>当useActualParamName()为true时: <img src="\cttImages\image-20191226191228811.png"><br>0 -&gt; “arg0”<br>1 -&gt; “myName”<br>2 -&gt;  “arg2” <img src="\cttImages\image-20191226185717234.png"> </li>
</ul>
</blockquote>
<h2 id="二-使用对应关系，绑定参数名与具体参数对象"><a href="#二-使用对应关系，绑定参数名与具体参数对象" class="headerlink" title="二.使用对应关系，绑定参数名与具体参数对象"></a>二.使用对应关系，绑定参数名与具体参数对象</h2><p>在之前的executeForMany中有这样的一个方法<br><code>Object param = this.method.convertArgsToSqlCommandParam(args);</code>具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperMethod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MapperMethod.SqlCommand command;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MapperMethod.MethodSignature method;</span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">        Object param = <span class="keyword">this</span>.method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        List result;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.method.hasRowBounds()) &#123;</span><br><span class="line">            RowBounds rowBounds = <span class="keyword">this</span>.method.extractRowBounds(args);</span><br><span class="line">            result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param, rowBounds);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = sqlSession.selectList(<span class="keyword">this</span>.command.getName(), param);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.method.getReturnType().isArray() ? <span class="keyword">this</span>.convertToArray(result) : <span class="keyword">this</span>.convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MapperMethod的方法convertArgsToSqlCommandParam</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convertArgsToSqlCommandParam</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.paramNameResolver.getNamedParams(args);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//ParamNameResolver的方法getNamedParams</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> paramCount = <span class="keyword">this</span>.names.size();</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; paramCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> args[(Integer)<span class="keyword">this</span>.names.firstKey()];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap();</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(Iterator var5 = <span class="keyword">this</span>.names.entrySet().iterator(); var5.hasNext(); ++i) &#123;</span><br><span class="line">                    Entry&lt;Integer, String&gt; entry = (Entry)var5.next();</span><br><span class="line">                    param.put(entry.getValue(), args[(Integer)entry.getKey()]);</span><br><span class="line">                    String genericParamName = <span class="string">"param"</span> + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.names.containsValue(genericParamName)) &#123;</span><br><span class="line">                        param.put(genericParamName, args[(Integer)entry.getKey()]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> param;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>遍历Map容器(即之前参数索引与参数名对应的map)names,以value作为key和args数组对应索引的值作为value存储到Map容器param中</li>
<li>根据GENERIC_NAME_PREFIX常量即”param”和当前的索引拼装成新的字符串,即param1,param2,…,paramN.然后和args数组里对应索引的值存储到Map容器param中</li>
</ol>
<blockquote>
<p>上面举得例子得到的结果  <img src="\cttImages\image-20191226185841103.png" alt="image-20191226185841103"> </p>
</blockquote>
<p>参考文章：<a href="https://blog.csdn.net/chenruicsdn/article/details/81370219，这篇博文有一定的错误" target="_blank" rel="noopener">https://blog.csdn.net/chenruicsdn/article/details/81370219，这篇博文有一定的错误</a></p>
]]></content>
  </entry>
  <entry>
    <title>源码分析 mybatis 读取配置文件</title>
    <url>/2019/08/02/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%20mybatis%20%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>持久层框架封装了jdbc的底层代码，我们需要提供的即sql、映射规则、pojo<br>研究mybatis，即</p>
<ol>
<li>mybatis怎么读取配置文件创建SqlSessionFactory</li>
<li>SqlSession运行过程</li>
</ol>
</blockquote>
<p><strong>这里更多探究的是mybatis怎么读取配置文件创建SqlSessionFactory</strong></p>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="一-简单执行流程"><a href="#一-简单执行流程" class="headerlink" title="一.简单执行流程"></a>一.简单执行流程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;<span class="comment">//执行如下代码</span></span><br><span class="line">        String resource= <span class="string">"mybatis.cfg.xml"</span>;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = Resources.getResourceAsStream(resource);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第一步，mybatis运行，创建SqlSessionFactoryBuilder工厂对象，调用build方法，读取配置文件信息存储在Configuration对象中，并创建SqlSessionFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">            var5 = <span class="keyword">this</span>.build(parser.parse());<span class="comment">//通过XML解析器解析，获得DefaultSqlSession对象</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, var14);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>第二步.创建SqlSession，赋予属性，从上一步获得的Configuration对象中，得到Environment环境信息，创建事务工厂，根据传入的事务隔离级别、是否自动提交的参数，创建事务对象。再根据事务、配置对象的执行器类型创建执行器对象，通过执行器对象创建SqlSession<br><strong>即事务工厂–&gt;事务–&gt;执行器–&gt;SqlSession</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSession <span class="title">openSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.openSessionFromDataSource(<span class="keyword">this</span>.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">        Transaction tx = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        DefaultSqlSession var8;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Environment environment = <span class="keyword">this</span>.configuration.getEnvironment();<span class="comment">//读取配置文件中的环境信息</span></span><br><span class="line">            TransactionFactory transactionFactory = <span class="keyword">this</span>.getTransactionFactoryFromEnvironment(environment);<span class="comment">//创建事务工厂</span></span><br><span class="line">            tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);<span class="comment">//根据传入的TransactionIsolationLevel、autoCommit创建事务对象</span></span><br><span class="line">            Executor executor = <span class="keyword">this</span>.configuration.newExecutor(tx, execType);<span class="comment">//根据事务、配置对象的执行器类型创建执行器对象，这里是SimpleExecutor</span></span><br><span class="line">            var8 = <span class="keyword">new</span> DefaultSqlSession(<span class="keyword">this</span>.configuration, executor, autoCommit);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var12) &#123;</span><br><span class="line">            <span class="keyword">this</span>.closeTransaction(tx);</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + var12, var12);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var8;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dirty:true  sql语句执行完毕后，事务提交,false  sql语句执行错误，事务回滚</li>
<li>Executor;可用于创建Statement对象，依靠MapperStatement对象将赋值内容与占位符进行绑定</li>
</ul>
<p>第三步.SqlSession关闭</p>
<h2 id="二-疑惑"><a href="#二-疑惑" class="headerlink" title="二.疑惑"></a>二.疑惑</h2><blockquote>
<p><strong>mybatis有xml、注解的使用方式</strong><br><a href="https://www.cnblogs.com/shamo89/p/9960370.html" target="_blank" rel="noopener">mybatis的使用方式(如果对使用方式不熟可以看这篇)</a></p>
</blockquote>
<p>1.对于Sql的xml是怎么被读取的、为什么xml文件名要规定一致，sql的#{ }是怎么替换的?<br>2.对于注解又是怎么读取注解中的配置的?</p>
<h2 id="三-解决"><a href="#三-解决" class="headerlink" title="三.解决"></a>三.解决</h2><h3 id="1-第一个问题"><a href="#1-第一个问题" class="headerlink" title="1.第一个问题"></a>1.第一个问题</h3><ol>
<li>创建SqlSessionFactory对象，关键在于这个build方法读取配置文件，并将配置信息放到Configuration对象中，进入build方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">            var5 = <span class="keyword">this</span>.build(parser.parse());<span class="comment">//通过XML解析器解析，获得DefaultSqlSessionFactory对象</span></span><br><span class="line">        &#125; <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>发现其中创建了一个XML解析器，调用了parse方法，进入parse方法</p>
<ol start="2">
<li>parse代码如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parsed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parsed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">this</span>.parseConfiguration(<span class="keyword">this</span>.parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到parse方法调用parseConfiguration找到configuration标签，读取内部内容，具体又是怎么读呢? 进入parseConfiguration方法</p>
<ol start="3">
<li>parseConfiguration方法如下，<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">            Properties settings = <span class="keyword">this</span>.settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">            <span class="keyword">this</span>.loadCustomVfs(settings);</span><br><span class="line">            <span class="keyword">this</span>.typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">            <span class="keyword">this</span>.pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">            <span class="keyword">this</span>.objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">            <span class="keyword">this</span>.objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">            <span class="keyword">this</span>.reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">            <span class="keyword">this</span>.settingsElement(settings);</span><br><span class="line">            <span class="keyword">this</span>.environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">            <span class="keyword">this</span>.databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">            <span class="keyword">this</span>.typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">            <span class="keyword">this</span>.mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + var3, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到很多见过的属性，即读取主配置文件的属性进到Configuration对象中，具体怎么读，以读取mappers为例(其下有package、mapper标签)进入mapperElement方法</p>
<ol start="3">
<li>mapperElement方法如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Iterator var2 = parent.getChildren().iterator();</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                    XNode child = (XNode)var2.next();</span><br><span class="line">                    String resource;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">                        resource = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">                        <span class="keyword">this</span>.configuration.addMappers(resource);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">                        String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">                        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">                        XMLMapperBuilder mapperParser;</span><br><span class="line">                        InputStream inputStream;</span><br><span class="line">                        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//...没截全</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>该方法判断是package还是mapper标签，然后读取进Configuration对象，具体怎么读呢?以packeage为例</p>
<ol start="4">
<li>读取package的代码如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">                        resource = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">                        <span class="keyword">this</span>.configuration.addMappers(resource);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>resource获得包名后，调用addMappers，有多个重载，最终调用到参数类型为String packageName, Class&lt;?&gt; superType的addMappers<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mapperRegistry.addMappers(packageName);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addMappers(packageName, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>最终调用的addMappers方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span> </span>&#123;<span class="comment">//最终调用到这个addMapper方法</span></span><br><span class="line">        ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> ResolverUtil();</span><br><span class="line">        resolverUtil.find(<span class="keyword">new</span> IsA(superType), packageName);</span><br><span class="line">        Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();</span><br><span class="line">        Iterator var5 = mapperSet.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var5.hasNext()) &#123;</span><br><span class="line">            Class&lt;?&gt; mapperClass = (Class)var5.next();</span><br><span class="line">            <span class="keyword">this</span>.addMapper(mapperClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中find方法去找当前工程有无该包，若有，经过匹配后，会加入到该resolverUtil中的Set对象中，通过getClasses得到该添加完毕的set对象。调用自身参数类型为Class<t> type的addMapper方法，进入该addMapper方法</t></p>
<ol start="6">
<li>自身参数类型为Class<t> type的addMapper方法如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.hasMapper(type)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory(type));<span class="comment">//准备加载的Class对象的map</span></span><br><span class="line">              MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(<span class="keyword">this</span>.config, type);</span><br><span class="line">              parser.parse();</span><br><span class="line">              loadCompleted = <span class="keyword">true</span>;<span class="comment">//加载完成，继续放在该map中</span></span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (!loadCompleted) &#123;<span class="comment">//加载未完成，从该map中移除出去</span></span><br><span class="line">                  <span class="keyword">this</span>.knownMappers.remove(type);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</t></li>
</ol>
<p>可以看到，最终通过MapperAnnotationBuilder.parser完成解析，从名称上Mapper注解的构建解析，解析过程肯定在这里，进去看看</p>
<ol start="7">
<li>具体的MapperAnnotationBuilder.parser方法，<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String resource = <span class="keyword">this</span>.type.toString();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.configuration.isResourceLoaded(resource)) &#123;<span class="comment">//已加载过则不执行</span></span><br><span class="line">            <span class="keyword">this</span>.loadXmlResource();<span class="comment">//加载寻找package对应的xml文件，有的话，则加载。没有则执行完向下</span></span><br><span class="line">            <span class="keyword">this</span>.configuration.addLoadedResource(resource);<span class="comment">//里面是Set，表示已加载的resource</span></span><br><span class="line">            <span class="keyword">this</span>.assistant.setCurrentNamespace(<span class="keyword">this</span>.type.getName());</span><br><span class="line">            <span class="keyword">this</span>.parseCache();<span class="comment">//解析缓存</span></span><br><span class="line">            <span class="keyword">this</span>.parseCacheRef();</span><br><span class="line">            Method[] methods = <span class="keyword">this</span>.type.getMethods();</span><br><span class="line">            Method[] var3 = methods;</span><br><span class="line">            <span class="keyword">int</span> var4 = methods.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">                Method method = var3[var5];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.parseStatement(method);<span class="comment">//如果读取了xml文件不会进入，未读，则在该方法中去类中读取注解</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IncompleteElementException var8) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.parsePendingMethods();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中有loadXmlResource方法，装载xml文件，装载什么配置文件呢，主配置文件装载过了，显然是映射的配置文件，进去看看</p>
<ol start="8">
<li>loadXmlResource代码如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadXmlResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.configuration.isResourceLoaded(<span class="string">"namespace:"</span> + <span class="keyword">this</span>.type.getName())) &#123;</span><br><span class="line">            String xmlResource = <span class="keyword">this</span>.type.getName().replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".xml"</span>;<span class="comment">//将配置文件中package配的/换成. ，得到对应的xml的文件名称(这就是为什么文件名称要统一的原因)</span></span><br><span class="line">            InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream = Resources.getResourceAsStream(<span class="keyword">this</span>.type.getClassLoader(), xmlResource);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var4) &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;<span class="comment">//读取到对应的配置文件</span></span><br><span class="line">                XMLMapperBuilder xmlParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, <span class="keyword">this</span>.assistant.getConfiguration(), xmlResource, <span class="keyword">this</span>.configuration.getSqlFragments(), <span class="keyword">this</span>.type.getName());</span><br><span class="line">                xmlParser.parse();<span class="comment">//进行解析</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们可以看到在这里会将配置文件中package配的”.”换成”/ “，得到对应的xml的文件名称(这就是为什么文件名称要统一的原因)，读取了该文件调用了xmlParser.parse()方法</p>
<ol start="9">
<li><p>xmlParser.parse()方法具体解析过程如下<br>*1.parse进行具体解析，代码如下，可以看到有个configurationElement方法读取了xml里mapper的sql信息，怎么读取的呢?</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.configuration.isResourceLoaded(<span class="keyword">this</span>.resource)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.configurationElement(<span class="keyword">this</span>.parser.evalNode(<span class="string">"/mapper"</span>));<span class="comment">//读取到mapper标签的内容进行具体解析，这个方法将参数换成了占位符!!!重要</span></span><br><span class="line">            <span class="keyword">this</span>.configuration.addLoadedResource(<span class="keyword">this</span>.resource);<span class="comment">//加入到已读map中</span></span><br><span class="line">            <span class="keyword">this</span>.bindMapperForNamespace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.parsePendingResultMaps();</span><br><span class="line">        <span class="keyword">this</span>.parsePendingCacheRefs();</span><br><span class="line">        <span class="keyword">this</span>.parsePendingStatements();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> *2.进入configurationElement方法，代码如下，其中的buildStatementFromContext方法中读取了具体的sql操作的标签信息，进buildStatementFromContext看看</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//获取对应参数</span></span><br><span class="line">            String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);<span class="comment">//获取命名空间</span></span><br><span class="line">            <span class="keyword">if</span> (namespace != <span class="keyword">null</span> &amp;&amp; !namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">                <span class="keyword">this</span>.cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));<span class="comment">//获取缓存信息</span></span><br><span class="line">                <span class="keyword">this</span>.cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">                <span class="keyword">this</span>.parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));/</span><br><span class="line">                <span class="keyword">this</span>.resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">                <span class="keyword">this</span>.sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));<span class="comment">//获取动态sql标签</span></span><br><span class="line">                <span class="keyword">this</span>.buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));<span class="comment">//具体的读取sql！！！</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + <span class="keyword">this</span>.resource + <span class="string">"'. Cause: "</span> + var3, var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>*3.追踪进buildStatementFromContext方法中，代码如下    
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.configuration.getDatabaseId() != <span class="keyword">null</span>) &#123;<span class="comment">//获取数据库的配置信息，不为null，则从Configuration中读取</span></span><br><span class="line">            <span class="keyword">this</span>.buildStatementFromContext(list, <span class="keyword">this</span>.configuration.getDatabaseId());</span><br><span class="line">        &#125;<span class="comment">//null时，传入null</span></span><br><span class="line">        <span class="keyword">this</span>.buildStatementFromContext(list, (String)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>*4.继续进入buildStatementFromContext方法中，名字上可以看出是创建Statement对象从Context中(应该是指写在xml中的sql语句)，在该方法中有一个statementParser.parseStatementNode()方法值得注意
</code></pre><p>(看到了熟悉的Statement)<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;</span><br><span class="line">        Iterator var3 = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(var3.hasNext()) &#123;<span class="comment">//获得单个的XNode</span></span><br><span class="line">            XNode context = (XNode)var3.next();</span><br><span class="line">            XMLStatementBuilder statementParser = <span class="keyword">new</span> XMLStatementBuilder(<span class="keyword">this</span>.configuration, <span class="keyword">this</span>.builderAssistant, context, requiredDatabaseId);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                statementParser.parseStatementNode();<span class="comment">//进行解析！！！</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IncompleteElementException var7) &#123;</span><br><span class="line">                <span class="keyword">this</span>.configuration.addIncompleteStatement(statementParser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>*5.进入statementParser.parseStatementNode方法，很多熟悉的配方，答案不远了
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String id = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">        String databaseId = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">            Integer fetchSize = <span class="keyword">this</span>.context.getIntAttribute(<span class="string">"fetchSize"</span>);</span><br><span class="line">            Integer timeout = <span class="keyword">this</span>.context.getIntAttribute(<span class="string">"timeout"</span>);</span><br><span class="line">            String parameterMap = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"parameterMap"</span>);</span><br><span class="line">            String parameterType = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"parameterType"</span>);</span><br><span class="line">            Class&lt;?&gt; parameterTypeClass = <span class="keyword">this</span>.resolveClass(parameterType);</span><br><span class="line">            String resultMap = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"resultMap"</span>);</span><br><span class="line">            String resultType = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"resultType"</span>);</span><br><span class="line">            String lang = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"lang"</span>);</span><br><span class="line">            LanguageDriver langDriver = <span class="keyword">this</span>.getLanguageDriver(lang);</span><br><span class="line">            Class&lt;?&gt; resultTypeClass = <span class="keyword">this</span>.resolveClass(resultType);</span><br><span class="line">            String resultSetType = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"resultSetType"</span>);</span><br><span class="line">            StatementType statementType = StatementType.valueOf(<span class="keyword">this</span>.context.getStringAttribute(<span class="string">"statementType"</span>, StatementType.PREPARED.toString()));</span><br><span class="line">            ResultSetType resultSetTypeEnum = <span class="keyword">this</span>.resolveResultSetType(resultSetType);</span><br><span class="line">            String nodeName = <span class="keyword">this</span>.context.getNode().getNodeName();</span><br><span class="line">            SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">            <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">            <span class="keyword">boolean</span> flushCache = <span class="keyword">this</span>.context.getBooleanAttribute(<span class="string">"flushCache"</span>, !isSelect);</span><br><span class="line">            <span class="keyword">boolean</span> useCache = <span class="keyword">this</span>.context.getBooleanAttribute(<span class="string">"useCache"</span>, isSelect);</span><br><span class="line">            <span class="keyword">boolean</span> resultOrdered = <span class="keyword">this</span>.context.getBooleanAttribute(<span class="string">"resultOrdered"</span>, <span class="keyword">false</span>);</span><br><span class="line">            XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(<span class="keyword">this</span>.configuration, <span class="keyword">this</span>.builderAssistant);</span><br><span class="line">            includeParser.applyIncludes(<span class="keyword">this</span>.context.getNode());</span><br><span class="line">            <span class="keyword">this</span>.processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            SqlSource sqlSource = langDriver.createSqlSource(<span class="keyword">this</span>.configuration, <span class="keyword">this</span>.context, parameterTypeClass);<span class="comment">//SqlSource(sql语句来源），这里调用了一个createSqlSource方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            String resultSets = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"resultSets"</span>);</span><br><span class="line">            String keyProperty = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"keyProperty"</span>);</span><br><span class="line">            String keyColumn = <span class="keyword">this</span>.context.getStringAttribute(<span class="string">"keyColumn"</span>);</span><br><span class="line">            String keyStatementId = id + <span class="string">"!selectKey"</span>;</span><br><span class="line">            keyStatementId = <span class="keyword">this</span>.builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">            Object keyGenerator;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">                keyGenerator = <span class="keyword">this</span>.configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                keyGenerator = <span class="keyword">this</span>.context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>, <span class="keyword">this</span>.configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType)) ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType, fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass, resultSetTypeEnum, flushCache, useCache, resultOrdered, (KeyGenerator)keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>发现有个方法createSqlSource，看名字就是创建sqlSource</p>
<blockquote>
<p>当parseStatementNode方法执行完毕时，会将结果放到MappedStatement里,即配置文件中所有的mapper信息读取完毕</p>
<p>MappedStatement中存放的信息</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedStatement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String resource;</span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Integer fetchSize;</span><br><span class="line">    <span class="keyword">private</span> Integer timeout;</span><br><span class="line">    <span class="keyword">private</span> StatementType statementType;</span><br><span class="line">    <span class="keyword">private</span> ResultSetType resultSetType;</span><br><span class="line">    <span class="keyword">private</span> SqlSource sqlSource;</span><br><span class="line">    <span class="keyword">private</span> Cache cache;</span><br><span class="line">    <span class="keyword">private</span> ParameterMap parameterMap;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultMap&gt; resultMaps;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flushCacheRequired;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> useCache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> resultOrdered;</span><br><span class="line">    <span class="keyword">private</span> SqlCommandType sqlCommandType;</span><br><span class="line">    <span class="keyword">private</span> KeyGenerator keyGenerator;</span><br><span class="line">    <span class="keyword">private</span> String[] keyProperties;</span><br><span class="line">    <span class="keyword">private</span> String[] keyColumns;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line">    <span class="keyword">private</span> String databaseId;</span><br><span class="line">    <span class="keyword">private</span> Log statementLog;</span><br><span class="line">    <span class="keyword">private</span> LanguageDriver lang;</span><br><span class="line">    <span class="keyword">private</span> String[] resultSets;</span><br></pre></td></tr></table></figure>
<pre><code>*6. 通过debug，进入到一个名为XMLLanguageDriver的类中的createSqlSource
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">        XMLScriptBuilder builder = <span class="keyword">new</span> XMLScriptBuilder(configuration, script, parameterType);</span><br><span class="line">        <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>*7.打开builder.parseScriptNode()方法,可以看到在这里开始判断使用哪种解析方式，是动态还是非动态
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MixedSqlNode rootSqlNode = <span class="keyword">this</span>.parseDynamicTags(<span class="keyword">this</span>.context);</span><br><span class="line">        SqlSource sqlSource = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isDynamic) &#123;<span class="comment">//判断是否为动态sql，是则调用</span></span><br><span class="line">            sqlSource = <span class="keyword">new</span> DynamicSqlSource(<span class="keyword">this</span>.configuration, rootSqlNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sqlSource = <span class="keyword">new</span> RawSqlSource(<span class="keyword">this</span>.configuration, rootSqlNode, <span class="keyword">this</span>.parameterType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (SqlSource)sqlSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>*8.打开RawSqlSource方法
</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RawSqlSource</span><span class="params">(Configuration configuration, SqlNode rootSqlNode, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(configuration, getSql(configuration, rootSqlNode), parameterType);</span><br><span class="line">    &#125;<span class="comment">//getSql(configuration, rootSqlNode)从名称可以得知，从配置对象，和读取的结点信息获取String类型的sql对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RawSqlSource</span><span class="params">(Configuration configuration, String sql, Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">        SqlSourceBuilder sqlSourceParser = <span class="keyword">new</span> SqlSourceBuilder(configuration);</span><br><span class="line">        Class&lt;?&gt; clazz = parameterType == null ? Object.class : parameterType;</span><br><span class="line">        <span class="keyword">this</span>.sqlSource = sqlSourceParser.parse(sql, clazz, <span class="keyword">new</span> HashMap());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用的是第一个构造方法，在该构造方法中又调用第二个构造方法，来创建RawSqlSource对象，在第二个构造方法中有sqlSourceParser.parse方法，很接近答案了<br>    *9.跟进sqlSourceParser.parse方法中<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parse</span><span class="params">(String originalSql, Class&lt;?&gt; parameterType, Map&lt;String, Object&gt; additionalParameters)</span> </span>&#123;</span><br><span class="line">        SqlSourceBuilder.ParameterMappingTokenHandler handler = <span class="keyword">new</span> SqlSourceBuilder.ParameterMappingTokenHandler(<span class="keyword">this</span>.configuration, parameterType, additionalParameters);</span><br><span class="line">        GenericTokenParser parser = <span class="keyword">new</span> GenericTokenParser(<span class="string">"#&#123;"</span>, <span class="string">"&#125;"</span>, handler);</span><br><span class="line">        String sql = parser.parse(originalSql);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StaticSqlSource(<span class="keyword">this</span>.configuration, sql, handler.getParameterMappings());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到mybaits在这里把#{,}切开来进行了替换，看最后的返回值为 return new StaticSqlSource(this.configuration, sql, handler.getParameterMappings());  根据名称可以知道一个是配置对象，一个是替换后的sql语句，一个是原先在#{}中的参数信息的集合，可以推出ParameterMappingTokenHandler对象应该是用于参数的存放<br><strong>第一个问题差不多就算是明白了，下一个问题</strong></p>
<h3 id="2-第二个问题"><a href="#2-第二个问题" class="headerlink" title="2.第二个问题"></a>2.第二个问题</h3><ol>
<li><p>回到MapperAnnotationBuilder的parse方法，当没有加载到对应的xml文件时，继续向下执行，在try，catch中，有一个if判断，如果读取了xml文件不会进入，未读，则调用parseStatement方法中去类中读取注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String resource = <span class="keyword">this</span>.type.toString();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.configuration.isResourceLoaded(resource)) &#123;<span class="comment">//已加载过则不执行</span></span><br><span class="line">            <span class="keyword">this</span>.loadXmlResource();<span class="comment">//加载寻找package对应的xml文件，有的话，则加载。没有则执行完向下</span></span><br><span class="line">            <span class="keyword">this</span>.configuration.addLoadedResource(resource);<span class="comment">//里面是Set，表示已加载的resource</span></span><br><span class="line">            <span class="keyword">this</span>.assistant.setCurrentNamespace(<span class="keyword">this</span>.type.getName());</span><br><span class="line">            <span class="keyword">this</span>.parseCache();<span class="comment">//解析缓存</span></span><br><span class="line">            <span class="keyword">this</span>.parseCacheRef();</span><br><span class="line">            Method[] methods = <span class="keyword">this</span>.type.getMethods();</span><br><span class="line">            Method[] var3 = methods;</span><br><span class="line">            <span class="keyword">int</span> var4 = methods.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">                Method method = var3[var5];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!method.isBridge()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.parseStatement(method);<span class="comment">//如果读取了xml文件不会进入，未读，则在该方法中去类中读取注解</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IncompleteElementException var8) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.configuration.addIncompleteMethod(<span class="keyword">new</span> MethodResolver(<span class="keyword">this</span>, method));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.parsePendingMethods();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入parseStatement方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parseStatement</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; parameterTypeClass = <span class="keyword">this</span>.getParameterType(method);</span><br><span class="line">        LanguageDriver languageDriver = <span class="keyword">this</span>.getLanguageDriver(method);</span><br><span class="line">        SqlSource sqlSource = <span class="keyword">this</span>.getSqlSourceFromAnnotations(method, parameterTypeClass, languageDriver);</span><br><span class="line">        <span class="keyword">if</span> (sqlSource != <span class="keyword">null</span>) &#123;<span class="comment">//没截全</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>仔细看有一个getSqlSourceFromAnnotations方法，获取SqlSource对象从注解中<br>3.进入getSqlSourceFromAnnotations方法,可以看到开始获得注解信息<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSource <span class="title">getSqlSourceFromAnnotations</span><span class="params">(Method method, Class&lt;?&gt; parameterType, LanguageDriver languageDriver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;? extends Annotation&gt; sqlAnnotationType = <span class="keyword">this</span>.getSqlAnnotationType(method);</span><br><span class="line">            Class&lt;? extends Annotation&gt; sqlProviderAnnotationType = <span class="keyword">this</span>.getSqlProviderAnnotationType(method);</span><br><span class="line">            Annotation sqlProviderAnnotation;</span><br><span class="line">            <span class="keyword">if</span> (sqlAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sqlProviderAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"You cannot supply both a static SQL and SqlProvider to method named "</span> + method.getName());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sqlProviderAnnotation = method.getAnnotation(sqlAnnotationType);</span><br><span class="line">                    String[] strings = (String[])((String[])sqlProviderAnnotation.getClass().getMethod(<span class="string">"value"</span>).invoke(sqlProviderAnnotation));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.buildSqlSourceFromStrings(strings, parameterType, languageDriver);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sqlProviderAnnotationType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sqlProviderAnnotation = method.getAnnotation(sqlProviderAnnotationType);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ProviderSqlSource(<span class="keyword">this</span>.assistant.getConfiguration(), sqlProviderAnnotation, <span class="keyword">this</span>.type, method);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var8) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Could not find value method on SQL annotation.  Cause: "</span> + var8, var8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>搞定收工!</strong></p>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>《设计模式之禅》 设计模式比较</title>
    <url>/2019/06/24/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="第三部分-谁的地盘谁做主-–-设计模式比较"><a href="#第三部分-谁的地盘谁做主-–-设计模式比较" class="headerlink" title="第三部分 谁的地盘谁做主 – 设计模式比较"></a>第三部分 谁的地盘谁做主 – 设计模式比较</h1><h2 id="一-创建类模式比较"><a href="#一-创建类模式比较" class="headerlink" title="一.创建类模式比较"></a>一.创建类模式比较</h2><h3 id="1-工厂方法模式-VS-建造者模式"><a href="#1-工厂方法模式-VS-建造者模式" class="headerlink" title="1.工厂方法模式 VS 建造者模式"></a>1.工厂方法模式 VS 建造者模式</h3><a id="more"></a>
<p><strong>不同点</strong></p>
<ul>
<li><p>意图不同<br>  <code>工厂方法</code>   注重整体对象的创建方法<br>  <code>建造者</code>  注重部分构建的过程，详细关注一个产品部件的生产、安装步骤</p>
</li>
<li><p>产品复杂度不同<br>  <code>工厂方法</code>   对象粒度比较粗<br>  <code>建造者</code>  对象粒度比较细</p>
</li>
</ul>
<h3 id="2-抽象工厂模式-VS-建造者模式"><a href="#2-抽象工厂模式-VS-建造者模式" class="headerlink" title="2.抽象工厂模式 VS 建造者模式"></a>2.抽象工厂模式 VS 建造者模式</h3><p><strong>不同点</strong><br>    <code>抽象工厂</code><br>        它是从一个更高层次去看对象的构建，具体到工厂内部还有很多的车间，这些都是隐藏在工厂内部的细节，对外不公布，比建造者的尺度要大<br>    <code>建造者</code><br>        使用在产品的装配方面，如通过装配不同的组件或者相同组件的不同顺序就可以产生一个新的对象</p>
<h2 id="二-结构类模式比较"><a href="#二-结构类模式比较" class="headerlink" title="二.结构类模式比较"></a>二.结构类模式比较</h2><h3 id="1-代理模式-VS-装饰模式"><a href="#1-代理模式-VS-装饰模式" class="headerlink" title="1.代理模式 VS 装饰模式"></a>1.代理模式 VS 装饰模式</h3><p><strong>共同点</strong>是两者具有相同的接口</p>
<p><strong>不同点</strong><br><code>代理模式</code></p>
<ul>
<li>着重对代理过程的控制</li>
<li>把当前的行为或功能委托给其他对象执行。代理类负责接口限定，是否可以调用真实对象，e.g. AOP</li>
</ul>
<p><code>装饰模式</code></p>
<ul>
<li>装饰模式是代理模式的一个特殊应用</li>
<li>在保证接口不变的情况下对类的功能进行加强or减弱，不做准入条件判断、准入参数过滤。e.g. java.io.* 包</li>
</ul>
<h3 id="2-装饰模式-VS-适配器模式"><a href="#2-装饰模式-VS-适配器模式" class="headerlink" title="2.装饰模式 VS 适配器模式"></a>2.装饰模式 VS 适配器模式</h3><p><strong>共同点</strong> 都是包装作用，通过委托的方式实现其功能</p>
<p><strong>不同点</strong></p>
<ul>
<li>意图不同<br><code>装饰模式</code> 加强对象的功能，不改变类的行为和属性<br><code>适配器模式</code> 着重转化(伪装)</li>
<li>施与对象不同<br><code>装饰模式</code>  包装的是自己的兄弟类，隶属于同一个家族(相同接口或父类)<br><code>适配器模式</code> 必须是两个(非相同接口)不同的对象</li>
<li>场景不同<br><code>装饰模式</code> 在任何情况下都可以使用<br><code>适配器模式</code> 一个补救模式</li>
<li>扩展性不同<br><code>装饰模式</code> 容易扩展<br><code>适配器模式</code> 一旦建立，后期去掉就比较困难了<h2 id="三-行为类模式比较"><a href="#三-行为类模式比较" class="headerlink" title="三.行为类模式比较"></a>三.行为类模式比较</h2><h3 id="1-命令模式-VS-策略模式"><a href="#1-命令模式-VS-策略模式" class="headerlink" title="1.命令模式 VS 策略模式"></a>1.命令模式 VS 策略模式</h3><strong>相似点</strong> 在命令模式退化时，比如无接收者(接收者非常简单或是一个java的基础操作，无需专门编写一个接收者)，这种情况下，两者的类图完全相同</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>关注点不同<br><code>命令模式</code> 着重解耦，通过将请求的内容封装为一个个的命令，来使得请求者和执行者解耦。且同时可以对命令进行多种处理，例如: 撤销、记录<br><code>策略模式</code> 着重算法的完整性、封装性</li>
<li>角色功能不同<blockquote>
<p>策略模式中的抽象算法和命令模式中的接收者非常相似。不过职责不同</p>
</blockquote>
</li>
</ul>
<p><code>命令模式</code>  关注命令的实现，即功能的实现。接收者的变更只影响到命令族的变更(接收者对命令负责)，对请求者(客户端)没有影响，影响范围仅仅只是抽象命令和具体命令，对它的修改不会扩散到其他模块<br><code>策略模式</code>  具体的算法负责一个完整的算法逻辑，是不可拆分的原子业务，当对具体算法进行变更时，就是对算法整体的变更(对客户端可能有影响)</p>
<ul>
<li>使用场景不同<br><code>命令模式</code>  适用于解耦两个有紧耦合关系的对象场合或者多命令多撤销的场景<br><code>策略模式</code>  适用于算法要求变换的场景</li>
</ul>
<blockquote>
<p>在命令模式中，我们可以把接收者设计得和策略模式的算法相同，也可以不同。在命令模式中，我们按照职责设计的接口就不适用于策略模式(书第一版418)<br>e.g. zip、gzip压缩 解压缩。接收者可设计成压缩类、解压缩类，也可设计成zip格式类、gzip格式类。在策略模式中，就不能设计成压缩算法类(包含zip、gzip算法)，解压缩算法类(包含zip、gzip算法)，当添加新的格式压缩时会违反开闭原则。所以只能设计成zip格式类(压缩、解压)、gzip格式类(压缩、解压)</p>
</blockquote>
<h3 id="2-策略模式-VS-状态模式"><a href="#2-策略模式-VS-状态模式" class="headerlink" title="2.策略模式 VS 状态模式"></a>2.策略模式 VS 状态模式</h3><p><strong>不同点</strong></p>
<ul>
<li><p>环境角色职责不同<br><code>策略模式</code>  起到一个委托作用，用于算法的替换<br><code>状态模式</code>  不仅仅是委托行为，还具有登记状态变化的功能</p>
</li>
<li><p>解决问题的方式不同<br><code>策略模式</code>   将具体策略类暴露出去，调用者需要具体明白每个策略的不同之处，保证算法可以自由切换<br><code>状态模式</code>   通过内在状态的改变而引起行为改变，状态的改变是由内部条件来改变的</p>
</li>
</ul>
<h3 id="3-责任链模式-VS-观察者模式"><a href="#3-责任链模式-VS-观察者模式" class="headerlink" title="3.责任链模式 VS 观察者模式"></a>3.责任链模式 VS 观察者模式</h3><p><strong>DNS解析过程</strong><br><code>责任链模式</code><br><img src="\cttImages\image-20191219195901007.png" alt="image-20191219195901007" style="zoom:67%;"></p>
<p><code>观察者模式</code><br><img src="\cttImages\image-20191219195938936.png" alt="image-20191219195938936" style="zoom:67%;"></p>
<p><strong>不同点</strong></p>
<ul>
<li><p>链中的消息对象不同<br><code>责任链模式</code>  基本上不会改变消息对象的结构，虽然每个节点都可以参与消费<br><code>观察者模式</code>  在链中传递的对象可以自由变化，只要上下级节点对传递的对象了解即可</p>
</li>
<li><p>上下节点的关系不同<br><code>责任链模式</code>  上下级节点之间没有关系<br><code>观察者模式</code>  上下级关系亲密，下级只关注上级节点的响应，上级只关注下级传递的请求</p>
</li>
<li><p>消息的分销渠道不同<br><code>责任链模式</code>  消息从链首传入后，就沿着链开始运动<br><code>观察者模式</code>  具有很大的灵活性，传递方式可以广播也可跳跃等…</p>
<h2 id="四-跨战区比较"><a href="#四-跨战区比较" class="headerlink" title="四.跨战区比较"></a>四.跨战区比较</h2><h3 id="1-策略模式-VS-桥梁模式"><a href="#1-策略模式-VS-桥梁模式" class="headerlink" title="1.策略模式 VS 桥梁模式"></a>1.策略模式 VS 桥梁模式</h3><p>附:  <a href="https://blog.csdn.net/xingjiarong/article/details/50333543" target="_blank" rel="noopener">https://blog.csdn.net/xingjiarong/article/details/50333543</a></p>
</li>
</ul>
<p><strong><code>策略模式</code></strong><br><img src="\cttImages\image-20191219200016476.png" alt="image-20191219200016476" style="zoom:67%;"></p>
<p><strong><code>桥接模式</code></strong><br><img src="\cttImages\image-20191219200203737.png" alt="image-20191219200203737" style="zoom:67%;"></p>
<p><strong>不同点</strong></p>
<ul>
<li><p>意图不同<br><code>策略模式</code>  将必要信息封装成一个对象就是一个行为<br><code>桥梁模式</code>  解决在不破坏封装的情况下，如何抽取出它的抽象部分和实现部分</p>
</li>
<li><p>变化上<br><code>策略模式</code>  并不考虑Context的变化，只有算法的课替代性。强调Strategy抽象接口的提供是一种算法，一般是无状态，无数据的，Context简单调用这些算法完成其操作<br><code>桥梁模式</code>  Implementor具有变化（ConcreteImplementor），而且Abstraction也可以发生变化（RefinedAbstraction），而且两者的变化是完全独立的，RefinedAbstraction与ConcreateImplementor之间松散耦合</p>
</li>
</ul>
<h3 id="2-门面模式-VS-中介者模式"><a href="#2-门面模式-VS-中介者模式" class="headerlink" title="2.门面模式 VS 中介者模式"></a>2.门面模式 VS 中介者模式</h3><p><strong>不同点</strong></p>
<ul>
<li><p>功能区别<br><code>门面模式</code>  增加了一个门面，对子系统来说没有增加任何功能。子系统脱离门面可以独立运行<br><code>中介者模式</code>   增加了业务功能，它把各个同事类中的原有耦合关系移植到了中介者，同事类不能脱离中介者而存在</p>
</li>
<li><p>知晓状态不同<br><code>门面模式</code>  子系统不知道有门面存在<br><code>中介者模式</code>   每个同事类都知道中介者的存在，且依靠中介者调和同事之间的关系</p>
</li>
<li><p>封装程度不同<br><code>门面模式</code>  一种简单的封装，所有的请求处理都委托给子系统完成<br><code>中介者模式</code>   一个中心，由中心协调同事类完成，并且中心本身也完成部分业务，中介者属于更进一步的业务功能封装</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>《设计模式之禅》</category>
      </categories>
  </entry>
  <entry>
    <title>《设计模式之禅》 结构类模式</title>
    <url>/2019/06/19/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B%20%E7%BB%93%E6%9E%84%E7%B1%BB%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><p>[TOC]</p>
<h2 id="第二部分-23种设计模式-结构类模式"><a href="#第二部分-23种设计模式-结构类模式" class="headerlink" title="第二部分 23种设计模式- 结构类模式"></a>第二部分 23种设计模式- 结构类模式</h2><blockquote>
<p>结构类模式: 描述类和对象之间如何进行有效的组织，以形成良好的软件体系结构</p>
</blockquote>
<a id="more"></a>
<h3 id="一-适配器模式"><a href="#一-适配器模式" class="headerlink" title="一.适配器模式"></a>一.适配器模式</h3><p><strong>1.定义</strong><br>将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法再一起工作的两个类能够在一起工作</p>
<blockquote>
<p>适配器模式又叫变压器模式</p>
</blockquote>
<p><strong>2.类图</strong></p>
<ol>
<li><p>类适配器<br><img src="\cttImages\image-20191219192724500.png" alt="image-20191219192724500" style="zoom:67%;"></p>
</li>
<li><p>对象适配器(使用的场景相对较多)<br><img src="\cttImages\image-20191219192815356.png" alt="image-20191219192815356" style="zoom:67%;"></p>
</li>
</ol>
<p><strong>3.角色</strong></p>
<ol>
<li><p>Target目标角色 — <strong>接口</strong><br>该角色定义把其他类转换为何种接口，也就是我们的期望接口</p>
</li>
<li><p>Adaptee源角色<br>它是已经存在的，运行良好的类或对象</p>
</li>
<li>Adapter适配器对象<br>适配器模式的核心角色，其他两个角色都是已经存在的角色。适配器角色需要新建立，用于把源角色转换成目标角色，通过继承或类关联的方式</li>
</ol>
<p><strong>4.优点</strong></p>
<ol>
<li>增加类的透明性</li>
<li>提高类的复用度</li>
<li>灵活性非常好</li>
</ol>
<p><strong>5.注意事项</strong><br>适配器模式在详细设计阶段不要考虑它，它不是为了解决还处在开发阶段的问题</p>
<h3 id="二-代理模式-委托模式"><a href="#二-代理模式-委托模式" class="headerlink" title="二.代理模式(委托模式)"></a>二.代理模式(委托模式)</h3><p><strong>1.定义</strong><br>为其他对象提供一种代理以控制对这个对象的访问<br><strong>2.类图</strong><br><img src="\cttImages\image-20191219192724500.png" alt="image-20191219192724500" style="zoom:80%;"></p>
<p><strong>3.角色</strong></p>
<ol>
<li><p>Subject 抽象主题角色<br>抽象主题类可以是抽象类也可以是接口。(包含需要被代理的方法)</p>
</li>
<li><p>RealSubject 具体主题角色<br>委托角色，被代理角色，业务逻辑的具体执行者</p>
</li>
<li><p>Proxy 代理主题角色<br>代理类。它负责对真实角色的应用，在真实角色处理完毕前后做预处理和善后处理工作</p>
</li>
</ol>
<p><strong>4.扩展</strong></p>
<ul>
<li>*1.普通代理<br>我们需要知道代理类的存在。需要自己new</li>
<li>*2.强制代理<br>调用者直接调用真实角色，而不用关心代理是否存在，代理从真实角色中产生</li>
<li>*3.虚拟代理<br>在需要的时候才初始化主题对象，可以避免被代理对象较多而引起的初始化缓慢问题。缺点是需要在每个方法中判断主题对象是否被创建</li>
<li>*4.动态代理 — 类图<br><img src="\cttImages\image-20191219193603515.png" alt="image-20191219193603515" style="zoom: 80%;"></li>
</ul>
<h3 id="三-装饰模式"><a href="#三-装饰模式" class="headerlink" title="三.装饰模式"></a>三.装饰模式</h3><p><strong>1.定义</strong><br>动态地给一个对象添加一些额外的职责，就增加功能</p>
<p><strong>2.类图</strong><br><img src="\cttImages\image-20191219193654957.png" alt="image-20191219193654957" style="zoom:80%;"></p>
<p><strong>3.角色</strong></p>
<ol>
<li><p>Component 抽象构件<br>一个接口或抽象类，原始对象。放需要加强的方法</p>
</li>
<li><p>ConcreteComponent具体构件<br>原始的接口或抽象类的实现</p>
</li>
<li><p>Decorator 装饰角色<br>聚合原始构件，实现接口或抽象方法，加以功能</p>
</li>
</ol>
<p><strong>4.应用</strong><br>优点: 装饰类和被装饰类可以独立发展，不会互相耦合。动态扩展一个实现类的功能<br>缺点: 多层装饰会比较复杂</p>
<blockquote>
<p>装饰器模式、代理模式比较</p>
<ul>
<li>装饰者模式：可以让使用者直观的看到增强了哪些功能。装饰者能够在运行时递归地被构造</li>
<li>代理模式：限制了使用者，只去调用代理，至于代理里面增加了什么功能，使用者是不知道，隐藏了一个对象的具体信息。代理和真实对象之间的的关系通常在编译时就已经确定</li>
</ul>
</blockquote>
<h3 id="四-组合模式"><a href="#四-组合模式" class="headerlink" title="四.组合模式"></a>四.组合模式</h3><p><strong>1.定义</strong><br>将对象组合成树形结构表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性</p>
<p><strong>2.类图</strong><br><img src="\cttImages\image-20191219193741848.png" alt="image-20191219193741848" style="zoom:67%;"></p>
<p><strong>3.角色</strong></p>
<ol>
<li><p>Component 抽象构件角色<br>定义组合对象的共有方法和属性，可以定义一些默认的行为或属性<br><img src="\cttImages\image-20191219193815191.png" alt="image-20191219193815191" style="zoom:67%;"></p>
</li>
<li><p>Leaf 叶子构件<br>叶子对象，其下再没有其他分支，即遍历的最小单元<br><img src="\cttImages\image-20191219194104047.png" alt="image-20191219194104047" style="zoom:67%;"></p>
</li>
<li><p>Composite 树枝构件<br>树枝对象，组合树枝节点和叶子节点形成一个树形结构<br><img src="\cttImages\image-20191219194410086.png" alt="image-20191219194410086" style="zoom:67%;"></p>
</li>
</ol>
<p><strong>遍历树结构</strong>，参考代码<br><img src="D:\InviAir\hexo\public\cttImages\image-20191219194455193.png" alt="image-20191219194455193" style="zoom:67%;"></p>
<p>组合模式是对依赖倒置原则的破坏。</p>
<p><strong>4.应用</strong><br>优点: 高层模块调用简单、节点自由增加<br>缺点: 直接使用了实现类，在面向接口编程上是很不恰当的，与依赖倒置原则冲突</p>
<p>使用场景: 维护和展示部分-整体关系、从一个整体中能够独立出部分模块或功能的场景</p>
<p><strong>5.扩展</strong><br>在实际项目中，树的组装信息是存储在关系型数据库中。我们从数据库读取出来，展示</p>
<ul>
<li><strong>5.1.安全模式</strong><br><code>类图</code><br><img src="\cttImages\image-20191219194612057.png" alt="image-20191219194612057" style="zoom:67%;"></li>
</ul>
<p>Component表示结点，区分叶子对象和树枝对象。不提供客户端不可能调用到的方法。但不够透明，因为叶子构件和容器构件具有不同的方法，必须有区别地对待叶子构件和容器构件。违反依赖倒置原则</p>
<ul>
<li><strong>5.2.透明模式</strong><br><code>类图</code><br><img src="\cttImages\image-20191219194848793.png" alt="image-20191219194848793" style="zoom:67%;"></li>
</ul>
<p>在该模式中不区分叶子、树枝对象。确保所有的构件类都有相同的接口，客户端可以相同地对待所有的对象。符合依赖倒置原则。但不够安全，因为叶子对象和容器对象在本质上是有区别的。提供add()、remove()以及getChild()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p>
<h3 id="五-门面模式-外观模式"><a href="#五-门面模式-外观模式" class="headerlink" title="五.门面模式(外观模式)"></a>五.门面模式(外观模式)</h3><p><strong>1. 定义</strong><br>要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行<br><strong>2. 类图</strong><br><img src="\cttImages\image-20191219194944056.png" alt="image-20191219194944056" style="zoom:67%;"></p>
<p><strong>3. 角色</strong></p>
<ol>
<li>Facade 门面角色<br>客户端呢可以调用这个角色的方法，该角色知道子系统的所有功能与职责</li>
<li>Subsystem 子系统角色</li>
</ol>
<p><strong>4. 应用</strong><br>优点: 减少系统的相互依赖、提高灵活性安全性<br>缺点: 不符合开闭原则，发现错误后需要去修改门面角色的代码</p>
<blockquote>
<ul>
<li>一个子系统可以有多个门面</li>
<li>门面不参与子系统内的业务逻辑</li>
</ul>
</blockquote>
<h3 id="六-享元模式"><a href="#六-享元模式" class="headerlink" title="六.享元模式"></a>六.享元模式</h3><p><strong>1. 定义</strong><br>使用共享对象有效地支持大量的细粒度的对象<br><strong>2. 类图</strong><br><img src="\cttImages\image-20191219195021020.png" alt="image-20191219195021020" style="zoom:67%;"></p>
<p><strong>3. 角色</strong></p>
<blockquote>
<p>外部状态: 该状态随环境改变而改变，是不可以共享的状态。对象得以依赖的一个标记<br>内部状态: 该状态不随环境改变而改变，存储在享元对象内部，对象可共享出来的信息</p>
</blockquote>
<ol>
<li><p>Flyweight 抽象享元角色<br>同时定义出对象的外部状态和内部状态<br><img src="\cttImages\image-20191219195057451.png" alt="image-20191219195057451" style="zoom:67%;"></p>
</li>
<li><p>ConcreteFlyweight 具体享元角色<br>具体的一个产品类，实现抽象角色定义。确定好内部状态(共享)，外部状态可供改变</p>
<blockquote>
<p>不能出现一个操作改变内部状态，同时改变外部状态</p>
</blockquote>
</li>
</ol>
<p><img src="\cttImages\image-20191219195156780.png" alt="image-20191219195156780" style="zoom:67%;"></p>
<ol start="3">
<li>unsharedConcreteFlyweight 不可共享的享元角色<br>不存在外部状态、有安全要求不能使用共享技术的对象。该对象一般不会出现在享元工厂中</li>
</ol>
<blockquote>
<p>使用抽象享元角色的属性，但不是共享对象</p>
</blockquote>
<ol start="4">
<li>FlyweightFactory 享元工厂<br>构造一个池容器，提供从池中获得对象的方法<br><img src="\cttImages\image-20191219195230119.png" alt="image-20191219195230119" style="zoom:67%;"></li>
</ol>
<blockquote>
<p>在程序开发中，确认只需要一次赋值的属性则设置为final类型，避免无意修改导致逻辑混乱</p>
</blockquote>
<p><strong>4. 应用</strong><br><code>优点</code><br>大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能</p>
<p><code>缺点</code><br>提高了系统复杂性，需要分离出外部状态和内部状态，且外部状态具有固化性，不随内部状态改变而改变，否则会导致系统的逻辑混乱</p>
<p><code>使用场景</code></p>
<ul>
<li>系统中存在大量的相似对象</li>
<li>需要缓冲池的场景</li>
</ul>
<p><strong>5. 扩展</strong></p>
<ol>
<li>线程安全问题</li>
</ol>
<h3 id="七-桥梁模式"><a href="#七-桥梁模式" class="headerlink" title="七.桥梁模式"></a>七.桥梁模式</h3><p><strong>1.定义</strong><br>将抽象和实现解耦，使得两者可以独立地变化</p>
<p><strong>2.类图</strong><br><img src="\cttImages\image-20191219195410905.png" alt="image-20191219195410905" style="zoom:67%;"></p>
<p><strong>3.角色</strong></p>
<ol>
<li>Abstraction 抽象化角色<br>主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类</li>
<li>Implementor 实现化角色<br>接口或者抽象类，定义角色必须的行为和属性</li>
<li>RefinedAbstraction 修正抽象化角色<br>引用实现化角色对抽象化角色进行修正</li>
<li>ConcreteImplementor 具体实现化角色<br>实现接口或抽象类定义的方法和属性</li>
</ol>
<blockquote>
<p>类似于聚合、合成的一种模式</p>
</blockquote>
<p><strong>4.应用</strong><br><code>优点</code></p>
<ul>
<li>抽象和实现分离</li>
<li>优秀的扩充能力</li>
<li>实现细节对客户透明</li>
</ul>
<p><code>使用场景</code></p>
<ul>
<li>不希望或不使用继承的场景</li>
<li>接口或抽象类不稳定的场景</li>
<li>重用性要求较高的场景</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>《设计模式之禅》</category>
      </categories>
  </entry>
  <entry>
    <title>《设计模式之禅》 行为类模式</title>
    <url>/2019/06/14/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B%20%E8%A1%8C%E4%B8%BA%E7%B1%BB%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><p>[TOC]</p>
<h2 id="第二部分-23种设计模式-行为类模式"><a href="#第二部分-23种设计模式-行为类模式" class="headerlink" title="第二部分 23种设计模式- 行为类模式"></a>第二部分 23种设计模式- 行为类模式</h2><a id="more"></a>
<blockquote>
<p>行为类模式: 描述类和对象之间如何交互及如何分配职责</p>
</blockquote>
<h3 id="一-策略模式"><a href="#一-策略模式" class="headerlink" title="一.策略模式"></a>一.策略模式</h3><p><strong>1.定义</strong></p>
<p>定义一组算法，将每个算法都封装起来，并使得它们可以互相转换<br><strong>2.类图</strong></p>
<p><img src="\cttImages\1574076112007.png" alt="1574076112007"><br><strong>3.角色</strong></p>
<ol>
<li>Context 封装角色<br> 上下文角色，对策略进行封装，屏蔽高层模块对策略算法的直接访问</li>
<li>Strategy抽象策略角色<br> 通常为接口，定义每个策略算法必须具有的方法和属性</li>
<li>ConcreteStrategy具体策略角色<br> 实现抽象策略中的操作</li>
</ol>
<blockquote>
<p><strong>相比代理模式</strong><br>策略模式中封装角色(代理角色) 与 被封装的策略类(原角色) 不是用同一个接口</p>
</blockquote>
<p><strong>4.优点</strong></p>
<ol>
<li>算法可以自由切换</li>
<li>避免使用多重条件判断</li>
<li>扩展性良好</li>
</ol>
<p><strong>5.缺点</strong></p>
<ol>
<li>策略类数量增多</li>
<li>所有策略类都要对外暴露</li>
</ol>
<h3 id="二-迭代器模式"><a href="#二-迭代器模式" class="headerlink" title="二.迭代器模式"></a>二.迭代器模式</h3><p><strong>1.定义</strong></p>
<p>它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节</p>
<blockquote>
<p>目前已经没落的模式</p>
</blockquote>
<p><strong>2.类图</strong><br><img src="\cttImages\1574076132128.png" alt="1574076132128"></p>
<p><strong>3.角色</strong></p>
<ol>
<li><p>Iterator抽象迭代器<br> <img src="\cttImages\1574076150431.png" alt="1574076150431"></p>
</li>
<li><p>ConcreteIterator具体迭代器</p>
</li>
<li>Aggregate抽象容器</li>
<li>ConcreteAggregate具体容器</li>
</ol>
<p><strong>4.应用</strong><br>java.util.Iterable接口( 只有一个方法: iterator() ) 已经应用到了各个集合类中。基本很少有项目再独立写迭代器，直接使用Collection下的实现类就可以解决问题。<strong>迭代器的使用将访问逻辑与数据结构分离开来，不同的数据结构都可以用同样的逻辑来读取这些数据</strong></p>
<h3 id="三-模版方法模式"><a href="#三-模版方法模式" class="headerlink" title="三.模版方法模式"></a>三.模版方法模式</h3><p><strong>1.定义</strong></p>
<p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤</p>
<p><strong>2.类图</strong><br><img src="\cttImages\1574076166402.png" alt="1574076166402"></p>
<p><strong>3.角色</strong></p>
<ol>
<li><p>AbstractClass 抽象模版，方法分为两类:</p>
<ul>
<li>基本方法(基本操作)，需由子类实现的方法，在模版方法时被调用</li>
<li>模版方法，一般是一个或几个，一般是一个具体方法，实现对基本方法的调度<blockquote>
<p>为了防止恶意操作，一般模版方法都加上final关键字，不允许被覆写</p>
</blockquote>
</li>
</ul>
</li>
<li><p>ConcreteClass1、ConcreteClass2 具体模版<br> 实现父类所定义的一个或多个抽象方法，也就是父类定义的基本方法在子类中得以实现</p>
</li>
</ol>
<p><strong>4.优点</strong></p>
<ol>
<li>封装不变部分，扩展可变部分</li>
<li>提取公共部分代码，便于维护</li>
<li>行为由父类控制，子类实现</li>
</ol>
<p><strong>5.扩展</strong></p>
<p>使用钩子函数，通过标识/子类的一个方法返回值决定公共部分的执行结果</p>
<h3 id="四-中介者模式"><a href="#四-中介者模式" class="headerlink" title="四.中介者模式"></a>四.中介者模式</h3><p><strong>1.定义</strong><br>使各对象不需要显示地互相作用，从而使器耦合松散，独立地改变它们之间的交互</p>
<p><strong>2.类图</strong><br><img src="\cttImages\1574076188097.png" alt="1574076188097"></p>
<p><strong>3.角色</strong></p>
<ol>
<li><p>Mediator 抽象中介者角色<br> 用于各同事角色之间的通信</p>
</li>
<li><p>Concrete Mediator 具体中介者角色<br> 协调各同事角色实现协作行为，因此依赖于各个同事角色</p>
</li>
<li><p>Colleague 同事角色<br> 每一个同事角色都知道中介者角色。行为分为同事本身的自发行为、依赖中介者的依赖行为</p>
</li>
</ol>
<blockquote>
<p>通用代码见设计模式之禅P174</p>
</blockquote>
<p><strong>4.应用</strong></p>
<p>优点: 减少类间的依赖，降低耦合<br>缺点: 中介者会膨胀得很大，逻辑复杂</p>
<p>使用场景: 类图中出现了蜘蛛网结构，中介者模式有利于把其梳理为星型结构</p>
<blockquote>
<p>实际应用</p>
<ol>
<li>MVC框架，C(Controller)就是一个中介者，作用就是将M(Model 业务逻辑)和V(View 视图)隔离开，协调M和V工作</li>
<li>媒体网关</li>
</ol>
</blockquote>
<h3 id="五-命令模式"><a href="#五-命令模式" class="headerlink" title="五.命令模式"></a>五.命令模式</h3><p><strong>1.定义</strong></p>
<p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能</p>
<p><strong>2.类图</strong></p>
<p><img src="\cttImages\1574076215508.png" alt="1574076215508"> </p>
<p><strong>3.角色</strong></p>
<ol>
<li><p>Receive 接受者角色<br> 干活的角色，命令传递到该角色执行</p>
</li>
<li><p>Command 命令角色<br> 需要执行的命令都在这声明</p>
</li>
<li><p>Invoker 调用者角色<br> 接收命令，并执行命令</p>
</li>
</ol>
<p><strong>4.应用</strong></p>
<p>优点: 类间解耦、可扩展性、<br>缺点: Command的子类可能会膨胀得很大</p>
<p><strong>5.实践</strong></p>
<ol>
<li>当客户反悔了，需要回滚。有两种方法，一 结合备忘录模式还原最后状态，二 新增一个反命令。在接受者中添加rollback方法</li>
<li>命令类的Receiver在实际应用中一般会被封装掉</li>
</ol>
<h3 id="六-责任链模式"><a href="#六-责任链模式" class="headerlink" title="六.责任链模式"></a>六.责任链模式</h3><p><strong>1.定义</strong><br>使多个对象都有机会处理请求，从而避免了请求发送者和接受者之间的耦合关系，将这些对象连成一条链，沿着这条链传递该请求，直到有对象处理它为止</p>
<p><strong>2.类图</strong><br><img src="\cttImages\1574076236959.png" alt="1574076236959"></p>
<p><strong>3.角色</strong></p>
<ol>
<li>Handler 抽象处理者—抽象类</li>
</ol>
<p><img src="\cttImages\1574076271765.png" alt="1574076271765"> </p>
<ol start="2">
<li>ConcreteHandler 具体实现类</li>
</ol>
<p>在处理中涉及了三个类<br><img src="\cttImages\1574076288847.png" alt="1574076288847"> </p>
<p>场景类<br><img src="\cttImages\1574076303447.png" alt="1574076303447"></p>
<p>在实际应用中，会有封装类对具体链的设置进行封装，简化高层次模块的调用，减少模块间的耦合</p>
<p><strong>4.应用</strong><br>优点: 将请求和处理分开<br>缺点: 性能问题，当链特别长时，调试不方便</p>
<p><strong>5.实践</strong><br>例子中的Handler时抽象类，融合了模版方法。每个实现类只需要关心echo方法处理请求，getHandlerLevel获得处理级别</p>
<h3 id="七-观察者模式-发布订阅模式"><a href="#七-观察者模式-发布订阅模式" class="headerlink" title="七.观察者模式(发布订阅模式)"></a>七.观察者模式(发布订阅模式)</h3><p><strong>1. 定义</strong></p>
<p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新</p>
<p><strong>2. 类图</strong></p>
<p><img src="\cttImages\1574076322197.png" alt="1574076322197"> </p>
<p><strong>3. 角色</strong></p>
<ol>
<li>Subject 被观察者<br> 定义被观察者必须实现的职责，能够动态增加、取消观察者</li>
<li>Observer 观察者<br> 观察者接收到消息，执行自己的业务逻辑update</li>
<li>ConcreteSubject 具体的被观察者</li>
<li>ConcreteObserver 具体的观察者</li>
</ol>
<p><strong>4. 应用</strong></p>
<p>优点: 观察者与被观察者对象是抽象耦合的、建立一套触发机制<br>缺点: 注意多级触发时的效率</p>
<blockquote>
<p>根据经验，一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消息最多被转发一次<br>util包提供了Observer、Observeble接口使用</p>
</blockquote>
<h3 id="八-备忘录模式"><a href="#八-备忘录模式" class="headerlink" title="八.备忘录模式"></a>八.备忘录模式</h3><p><strong>1. 定义</strong></p>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以后可将该对象恢复到原先保存的状态</p>
<p><strong>2. 类图</strong></p>
<p><img src="\cttImages\1574076336706.png" alt="1574076336706"> </p>
<p><strong>3. 角色</strong></p>
<ol>
<li>Originator 发起人角色<br> 记录当前时刻的内部状态，负责定义哪些属性需要备份，创建、恢复备忘录数据</li>
<li>Memento 备忘录角色<br> 负责存储Originator 对象的内部状态</li>
<li>Caretaker 备忘录管理员角色<br> 对备忘录进行管理，保存和提供备忘录</li>
</ol>
<p><strong>4. 应用</strong></p>
<p><code>使用场景</code></p>
<ul>
<li>需要保存及恢复数据</li>
<li>提供回滚操作</li>
</ul>
<p><code>注意事项</code></p>
<ul>
<li>备忘录的生命期</li>
<li>备忘录的性能</li>
</ul>
<p><strong>5. 扩展</strong></p>
<ol>
<li>clone方式创建备忘录<br> 通过让发起人实现Clonable接口</li>
<li>多状态的备忘录模式(这一部分的事例代码看的有点点不懂)</li>
<li>多备份备忘录<br> 存储备忘录通过容器类</li>
<li>安全性封装<br> 类图如下: <img src="cttImages\1574076359350.png" alt="1574076359350"><br> 外部只保留一个空接口，数据存储在Caretaker，当要恢复取得对象时，只有在发起人类中才能将拿到的对象，转换成正确的类型</li>
</ol>
<h3 id="九-访问者模式"><a href="#九-访问者模式" class="headerlink" title="九.访问者模式"></a>九.访问者模式</h3><p><strong>1. 定义</strong></p>
<p>封装一些作用于某种数据结构中的各元素的操作，在不改变数据结构的前提下定义作用于这些元素的新操作</p>
<p><strong>2. 类图</strong></p>
<p><img src="\cttImages\1574076385943.png" alt="1574076385943"> </p>
<p><strong>3. 角色</strong></p>
<ol>
<li><p>Visitor 抽象访问者<br> 抽象类或接口，声明访问者可以访问哪些元素<br> <img src="\cttImages\1574076403818.png" alt="1574076403818"></p>
</li>
<li><p>ConcreteVisitor 具体访问者<br> <img src="\cttImages\1574076418787.png" alt="1574076418787"></p>
</li>
<li><p>Element 抽象元素<br> 抽象类或接口，声明接受哪一类访问者访问。通过accept方法的参数定义</p>
</li>
<li>ConcreteElement 具体元素</li>
<li>ObjectStruture 结构对象<br> 元素生产者</li>
</ol>
<p><strong>4. 应用</strong></p>
<p><code>优点</code></p>
<ul>
<li>符合单一职责原则</li>
<li>优秀的扩展性</li>
<li>灵活性非常高</li>
</ul>
<p><code>缺点</code></p>
<ul>
<li>具体元素对访问者公布细节</li>
<li>具体元素的变更困难</li>
<li>违背了依赖倒置原则，访问者依赖具体元素，不是接口</li>
</ul>
<blockquote>
<p>访问者模式是对迭代器模式的扩充</p>
</blockquote>
<h3 id="十-状态模式"><a href="#十-状态模式" class="headerlink" title="十.状态模式"></a>十.状态模式</h3><p><strong>1. 定义</strong></p>
<p>当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类</p>
<p><strong>2. 类图</strong></p>
<p><img src="\cttImages\1574076433792.png" alt="1574076433792"></p>
<p><strong>3. 角色</strong></p>
<ol>
<li>State 抽象状态角色<br> 接口或抽象类，负责对象状态定义，封装环境角色实现状态切换<br> <img src="\cttImages\1574076447299.png" alt="1574076447299"></li>
</ol>
<blockquote>
<p>定义了每个状态下的方法</p>
</blockquote>
<ol start="2">
<li>ConcreteState 具体状态角色<br> <code>每个具体状态需要完成的两个职责:</code><ul>
<li>本状态的行为管理</li>
<li>本状态过渡到其他状态<br><img src="\cttImages\1574076461709.png" alt="1574076461709"></li>
</ul>
</li>
</ol>
<blockquote>
<p>具体状态下，对对应方法的实现，及切换状态(改变Context中的状态角色)</p>
</blockquote>
<ol start="3">
<li>Context 环境角色<br> 定义客户端需要的接口，并且负责具体状态的切换<br> <img src="\cttImages\1574076494353.png" alt="1574076494353"></li>
</ol>
<blockquote>
<p>不成文约束:</p>
<ul>
<li>把状态对象声明为静态常量，有几个状态就声明几个</li>
<li>环境角色具有状态抽象角色的所有行为。具体执行使用委托方式</li>
</ul>
</blockquote>
<p>附: 场景类<br><img src="\cttImages\1574076504604.png" alt="1574076504604"></p>
<p><strong>4. 应用</strong></p>
<blockquote>
<p>工作流</p>
</blockquote>
<p><code>优点</code></p>
<ul>
<li>结构清晰</li>
<li>遵循设计原则</li>
<li>封装性好</li>
</ul>
<p><code>缺点</code> : 子类太多，会造成类膨胀</p>
<p><code>使用场景</code> : 行为随状态改变而改变，条件分支判断语句的替代者</p>
<h3 id="十一-解释器模式"><a href="#十一-解释器模式" class="headerlink" title="十一.解释器模式"></a>十一.解释器模式</h3><p>按照一种规定语法进行解析的方案，在项目中使用的较少<br><strong>1.定义</strong><br>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</p>
<blockquote>
<p><strong>不详细写</strong></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>《设计模式之禅》</category>
      </categories>
  </entry>
  <entry>
    <title>《设计模式之禅》 创建类模式</title>
    <url>/2019/06/04/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B%E5%88%9B%E5%BB%BA%E7%B1%BB%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><p>[TOC]</p>
<h2 id="第二部分-23种设计模式-创建类模式"><a href="#第二部分-23种设计模式-创建类模式" class="headerlink" title="第二部分 23种设计模式- 创建类模式"></a>第二部分 23种设计模式- 创建类模式</h2><a id="more"></a>
<blockquote>
<p>创建类模式: 使软件模块做到与对象的创建和组织无关</p>
</blockquote>
<h3 id="一-单例模式"><a href="#一-单例模式" class="headerlink" title="一.单例模式"></a>一.单例模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>确保某一个类只有一个实例，并自省实例化向整个系统提供这个实例</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>一般没有接口，扩展很困难。除了修改代码基本没有第二种途径</li>
<li>对测试不利</li>
<li>与单一职责原则有冲突</li>
</ol>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ol>
<li>懒汉式、饿汉式</li>
<li>带固定数量的单例</li>
</ol>
<h3 id="二-工厂方法模式"><a href="#二-工厂方法模式" class="headerlink" title="二.工厂方法模式"></a>二.工厂方法模式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例化延迟到其子类</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>降低模块间耦合，一个调用者需要一个具体的产品对象，只要知道这个产品的类名就可以了，不用知道创建对象的艰辛过程</p>
<h4 id="扩展-1"><a href="#扩展-1" class="headerlink" title="扩展"></a>扩展</h4><ol>
<li><p>简单工厂模式<br> 工厂类没有抽象类或接口(使用static方法调用)，产品有通用的接口。通过提供标识让工厂生产</p>
<p>类图**</p>
<p><img src="\cttImages\1573999817681.png" alt="1573999817681"> </p>
</li>
<li><p>工厂方法模式(每个产品提供对应的创建者)<br> 工厂类有抽象类或接口, 需要创建出工厂后调用</p>
<p><strong>类图</strong></p>
<p><img src="\cttImages\1573999855220.png" alt="1573999855220"> </p>
</li>
<li><p>替代单例模式<br> 单例的类不提供静态方法创建实例，通过工厂的静态方法来创建(通过反射)</p>
<p><strong>类图</strong></p>
<p><img src="\cttImages\1573999897554.png" alt="1573999897554"> </p>
</li>
<li><p>延迟初始化: 一个对象被消费完毕后，并不立刻释放，工厂类保持初始状态，等待再次被使用</p>
<ul>
<li><strong>应用场景</strong>: 限制某个产品类的最大实例化数量 JDBC设置的最大连接数量…</li>
<li><strong>类图</strong><br><img src="\cttImages\1573999949429.png" alt="1573999949429"> </li>
</ul>
</li>
</ol>
<h3 id="三-抽象工厂模式"><a href="#三-抽象工厂模式" class="headerlink" title="三.抽象工厂模式"></a>三.抽象工厂模式</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p>为创建一组相关或相互依赖的对象提供一个接口，而且无需指定它们的具体实现类</p>
<h4 id="2-类图"><a href="#2-类图" class="headerlink" title="2.类图"></a>2.类图</h4><p><img src="\cttImages\1574075965522.png" alt="1574075965522"> </p>
<blockquote>
<p>工厂方法模式的升级版本。在有多个业务品种、业务分类时，是一种很好的解决方式</p>
</blockquote>
<h4 id="3-优点"><a href="#3-优点" class="headerlink" title="3.优点"></a>3.优点</h4><ol>
<li>封装性</li>
<li>产品族内的约束为非公开的</li>
</ol>
<h4 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4.缺点"></a>4.缺点</h4><p>横向扩展容易，但纵向扩展困难</p>
<blockquote>
<p><strong>比较 简单工厂、工厂方法、抽象工厂</strong></p>
<ul>
<li>简单工厂: 没有工厂接口，需要什么产品，对应传入标识，获得</li>
<li>工厂方法: 含有工厂接口(接口内就一个生产方法)，分类后，只管生产分类所对应的单一商品，不用传入标识。如: 人类工厂划分为黄人、黑人、白人工厂，黄人工厂只生产黄人</li>
<li>抽象工厂: 含有工厂接口(接口内有多个生产方法)，分类后，只管生产分类的一系列商品，不用传入标识。如: 人类工厂划分为黄人、黑人、白人工厂，黄人工厂只生产黄人男人、黄人女人</li>
</ul>
</blockquote>
<h3 id="四-建造者模式-生成器模式"><a href="#四-建造者模式-生成器模式" class="headerlink" title="四.建造者模式(生成器模式)"></a>四.建造者模式(生成器模式)</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p>
<h4 id="2-类图-1"><a href="#2-类图-1" class="headerlink" title="2.类图"></a>2.类图</h4><p><img src="\cttImages\1574075997337.png" alt="1574075997337"> </p>
<h4 id="3-角色"><a href="#3-角色" class="headerlink" title="3.角色"></a>3.角色</h4><ol>
<li><p>Product 产品类<br>通常是实现了模版方法模式，也就是有模版方法和基本方法</p>
</li>
<li><p>Builder 抽象建造者<br>规范产品的组建，一般由子类实现</p>
</li>
<li><p>ConcreteBuilder 具体建造者<br>实现抽象类定义的所有方法，并返回一个组建好的对象</p>
</li>
<li><p>Director 导演类<br>负责安排已有模块的顺序，然后告诉Build开始组件。起到封装的作用，避免高层模块深入到建造者内部的实现类</p>
</li>
</ol>
<h4 id="4-优点"><a href="#4-优点" class="headerlink" title="4.优点"></a>4.优点</h4><ol>
<li>封装性</li>
<li>建造者独立，容易扩展</li>
<li>便于控制细节风险</li>
</ol>
<h4 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5.使用场景"></a>5.使用场景</h4><ol>
<li>不同的执行顺序，产生不同的事件结果</li>
<li>多个零件或部件</li>
</ol>
<blockquote>
<p>工厂方法模式，关注的重点是创建，创建零件<br>建造者模式，关注的重点是零件的装配，顺序不同产生的对象也不同</p>
</blockquote>
<h3 id="五-原型模式"><a href="#五-原型模式" class="headerlink" title="五.原型模式"></a>五.原型模式</h3><h4 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h4><p>用原型实例指定创建对象的种类，并且拷贝这些原型创建对象</p>
<h4 id="2-类图-2"><a href="#2-类图-2" class="headerlink" title="2.类图"></a>2.类图</h4><p><img src="\cttImages\1574076013656.png" alt="1574076013656"> </p>
<h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h4><p>实体类实现cloneable接口，重写clone方法</p>
<ul>
<li>浅拷贝<br><img src="\cttImages\image-20191219115531616.png" alt="image-20191219115531616" style="zoom:80%;"></li>
</ul>
<p>直接通过Object的clone方法进行拷贝，只拷贝本对象，对象内部的数组、引用对象都不拷贝，指向原生对象的内部元素地址。(在这里String可以当作基本类型使用)</p>
<ul>
<li>深拷贝<br><img src="\cttImages\image-20191219115623065.png" alt="image-20191219115623065" style="zoom:80%;"></li>
</ul>
<p>对私有的类变量进行独立的拷贝</p>
<h4 id="4-优点-1"><a href="#4-优点-1" class="headerlink" title="4.优点"></a>4.优点</h4><ol>
<li>性能优良</li>
<li>逃避构造函数的约束</li>
</ol>
<h4 id="5-使用场景-1"><a href="#5-使用场景-1" class="headerlink" title="5.使用场景"></a>5.使用场景</h4><ol>
<li>资源优化场景</li>
<li>性能和安全要求</li>
<li>一个对象多个修改者的场景</li>
</ol>
<blockquote>
<p>要使用clone方法，在类的成员变量上就不要增加final关键字</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>《设计模式之禅》</category>
      </categories>
  </entry>
  <entry>
    <title>《设计模式之禅》 六大设计原则</title>
    <url>/2019/03/15/%E3%80%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85%E3%80%8B%20%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="设计模式之禅"><a href="#设计模式之禅" class="headerlink" title="设计模式之禅"></a>设计模式之禅</h1><p>[TOC]</p>
<h2 id="第一部分-六大原则"><a href="#第一部分-六大原则" class="headerlink" title="第一部分 六大原则"></a>第一部分 六大原则</h2><a id="more"></a>
<h3 id="一-单一职责原则-SRP-Single-Responsibility-Principle"><a href="#一-单一职责原则-SRP-Single-Responsibility-Principle" class="headerlink" title="一.单一职责原则(SRP:Single Responsibility Principle)"></a>一.单一职责原则(SRP:Single Responsibility Principle)</h3><ul>
<li>定义:应该有且仅有一个原因引起类的变更<br>建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化，也适用于方法</li>
<li>优点:<ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多</li>
<li>提高类的可读性，提高系统的可维护性</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响</li>
</ul>
</li>
</ul>
<h3 id="二-里氏替换原则-LSP-Liskov-Substitution-Principle"><a href="#二-里氏替换原则-LSP-Liskov-Substitution-Principle" class="headerlink" title="二.里氏替换原则(LSP:Liskov Substitution Principle)"></a>二.<a href="https://www.cnblogs.com/hellojava/archive/2013/03/15/2960905.html" target="_blank" rel="noopener">里氏替换原则(LSP:Liskov Substitution Principle)</a></h3><ul>
<li>定义:所有引用基类的地方必须能透明地使用其他子类对象</li>
<li>含义:<ol>
<li>子类必须完全实现父类的方法<br>如果子类不能完整的实现父类的方法，建议断开父子继承关系，采用<a href="https://www.jianshu.com/p/ee0c26bcbf3d" target="_blank" rel="noopener">依赖、<br>聚合、组合</a>等关系来替代</li>
<li>子类可以有自己的个性</li>
<li>覆盖或实现方法时输入参数(前置条件)可以被放大</li>
<li>覆写或实现父类方法时输出结果(后置条件)可以被缩小</li>
</ol>
</li>
</ul>
<p>依赖:强调的是<strong>使用上的关系</strong>，是单向的<br>关联(聚合、组合):</p>
<ul>
<li>聚合(has-a):整体和部分都可以有各自的声明周期</li>
<li>组合(contains-a):整体和部分不可分割<br>UML图指向整体，聚合为空心菱形，组合为实心</li>
</ul>
<blockquote>
<p>UML类图的画法见另一份笔记<br>继承是is-a。接口是like-a。参考博文: <a href="https://blog.csdn.net/jy55149676/article/details/80537779" target="_blank" rel="noopener">https://blog.csdn.net/jy55149676/article/details/80537779</a></p>
</blockquote>
<h3 id="三-依赖倒置原则-DIP-Dependence-Inversion-Principle"><a href="#三-依赖倒置原则-DIP-Dependence-Inversion-Principle" class="headerlink" title="三.依赖倒置原则(DIP:Dependence Inversion Principle)"></a>三.依赖倒置原则(DIP:Dependence Inversion Principle)</h3><ul>
<li><p>含义:</p>
<ol>
<li>高层模块不应该依赖低层模块，两者应该依赖其抽象</li>
<li>抽象不应该依赖细节</li>
<li>细节应该依赖抽象<blockquote>
<p>不可分割的原子逻辑就是低层模块，原子逻辑再组装就是高层模块<br>java语言中，抽象:接口或抽象类，细节:可以直接被实例化</p>
</blockquote>
</li>
</ol>
</li>
<li><p>实践:</p>
<ol>
<li>每个类尽量都有接口或抽象类</li>
<li>变量的表面类型尽量是接口或抽象类</li>
<li>任何类都不应该从具体类派生</li>
</ol>
</li>
</ul>
<h3 id="四-接口隔离原则-Interface-Segregation-Principle"><a href="#四-接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="四.接口隔离原则(Interface Segregation Principle)"></a>四.接口隔离原则(Interface Segregation Principle)</h3><ul>
<li>定义:客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上<br>接口要尽量小，但也是有限度的</li>
<li>优点:通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性<blockquote>
<p>单一职责与接口隔离对比：两者审视的角度不同<br>单一职责注重业务逻辑的划分；接口隔离注重接口的方法应该尽量少，只暴露别人需要的部分<br>根据接口隔离原则划分接口的时候，首先必须满足单一职责原则</p>
</blockquote>
</li>
</ul>
<h3 id="五-迪米特法则"><a href="#五-迪米特法则" class="headerlink" title="五.迪米特法则"></a>五.迪米特法则</h3><ul>
<li>定义:一个对象应该对其他对象有最少了解（只与朋友类交流、两部分之间的交流做适当的控制）</li>
<li>优点：弱耦合（弱耦合可以使得类的复用率提高，但是会产生大量的中转类，导致系统复杂性的提高）</li>
</ul>
<h3 id="六-开闭原则"><a href="#六-开闭原则" class="headerlink" title="六.开闭原则"></a>六.开闭原则</h3><ul>
<li>定义:一个软件实体应该对扩展开放，对修改关闭<br>(前面五个原则是对开闭原则的具体解释)</li>
<li>优点：在对扩展开放的同时，尽量减少对原有代码的修改，保持历史代码的纯洁性，提高系统的稳定性</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>《设计模式之禅》</category>
      </categories>
  </entry>
  <entry>
    <title>《深入浅出Mybatis技术原理与实战》 插件使用及原理</title>
    <url>/2019/03/10/mybatis%20%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="mybatis-插件使用及原理"><a href="#mybatis-插件使用及原理" class="headerlink" title="mybatis 插件使用及原理"></a>mybatis 插件使用及原理</h1><p>[TOC]</p>
<h2 id="一-插件使用"><a href="#一-插件使用" class="headerlink" title="一. 插件使用"></a>一. 插件使用</h2><a id="more"></a>
<h3 id="1-接口说明"><a href="#1-接口说明" class="headerlink" title="1. 接口说明"></a>1. <strong>接口说明</strong></h3><p><img src="\cttImages\1573997885762.png" alt="1573997885762"> </p>
<ul>
<li>intercept方法:将直接覆盖你所拦截对象原有的方法。参数Invocation中的- proceed可以调用原来的方法</li>
<li>plugin方法:var1为被拦截对象，该方法为被拦截的对象生成一个代理对象</li>
<li>setProperties方法:允许在plugin元素中配置所需参数，在插件初始化时，被调用一次，把插件对象存到配置中，方便以后取出</li>
</ul>
<h3 id="2-接口示例"><a href="#2-接口示例" class="headerlink" title="2. 接口示例"></a>2. <strong>接口示例</strong></h3><h4 id="2-1-插件接口"><a href="#2-1-插件接口" class="headerlink" title="2.1. 插件接口"></a>2.1. 插件接口</h4><p><img src="\cttImages\1573997925849.png" alt="1573997925849"> </p>
<p><strong>1. 说明</strong></p>
<ul>
<li>创建该接口的类需要加上对象的注解@Intercepts @Signature，标明拦截的类及方法</li>
<li>mybatis提供Plugin工具类，是InvocationHandler接口的实现，该类的wrap方法可用于生成代理对象</li>
</ul>
<p><strong>2. Plugin.wrap方法</strong>: 传入参数为当前要被代理的对象，及拦截器。具体的代理内容为其invoke方法执行的东西<br><img src="\cttImages\1573998103846.png" alt="1573998103846"></p>
<p>这里判断所执行的方法是否为拦截方法，是则执行拦截器中的方法，不是则不拦截，调用其本身</p>
<h4 id="2-2-相关配置"><a href="#2-2-相关配置" class="headerlink" title="2.2. 相关配置"></a>2.2. 相关配置</h4><p><img src="\cttImages\1573998126255.png" alt="1573998126255"> </p>
<blockquote>
<p>当运行的时候，有调用到该方法即可以使用了</p>
</blockquote>
<h2 id="二-插件原理"><a href="#二-插件原理" class="headerlink" title="二. 插件原理"></a>二. 插件原理</h2><h3 id="1-插件初始化"><a href="#1-插件初始化" class="headerlink" title="1. 插件初始化"></a>1. 插件初始化</h3><p>创建Configuration对象时，调用pluginElement方法读取plugin标签内容</p>
<p><strong>源码图</strong><br><img src="\cttImages\1573998151449.png" alt="1573998151449"></p>
<p><strong>说明</strong></p>
<ul>
<li>通过反射生成插件实例，并调用了setProperties</li>
<li>使用List保存生成插件实例</li>
</ul>
<blockquote>
<p>这里setProperties方法，使用了模版方法设计模式</p>
</blockquote>
<h3 id="2-拦截范围"><a href="#2-拦截范围" class="headerlink" title="2. 拦截范围"></a>2. 拦截范围</h3><blockquote>
<p>提供的拦截范围为: 四大对象</p>
</blockquote>
<p><strong>1. 如何拦截</strong>: 以Executor为例，其余对象均相同</p>
<p><img src="\cttImages\1573998170093.png" alt="1573998170093"><br><img src="\cttImages\1573998189792.png" alt="1573998189792"></p>
<p>这里使用到了责任链模式，MyBatis的责任链由Configuration中的InterceptorChain对象去定义的。这里Executor对象不断被链中的插件进行代理(可以代理很多层)</p>
<blockquote>
<p>InterceptorChain类十分简单，可以去看看源码，这里就不贴了</p>
</blockquote>
<h2 id="三-插件的常用工具类"><a href="#三-插件的常用工具类" class="headerlink" title="三. 插件的常用工具类"></a>三. 插件的常用工具类</h2><blockquote>
<p>没具体看，有个印象即可</p>
</blockquote>
<p><strong>MetaObject</strong></p>
<p>四大对象提供给我们的public设置参数的方法很少，难以通过自身得到相关的属性信息，我们可以通过MetaObject这个工具类来读取或修改这些重要对象的属性</p>
<p><strong>三个常用方法:</strong></p>
<ul>
<li>SystemMetaObejct.forObject(Object obj)，用于包装对象<br>(forObject 并不是太清楚)</li>
<li>Object getValue(String name)，用于获取对象属性值</li>
<li>void setValue(String name，Object value)，用于修改对象属性值</li>
</ul>
<h2 id="四-插件总结"><a href="#四-插件总结" class="headerlink" title="四. 插件总结"></a>四. 插件总结</h2><p><img src="\cttImages\1573998210784.png" alt="1573998210784"> </p>
]]></content>
      <categories>
        <category>源码分析</category>
        <category>mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>mybatis 缓存</title>
    <url>/2019/01/26/mybatis-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="一-mybatis-两级缓存"><a href="#一-mybatis-两级缓存" class="headerlink" title="一.mybatis 两级缓存"></a>一.mybatis 两级缓存</h1><h2 id="1-一级缓存-本地缓存"><a href="#1-一级缓存-本地缓存" class="headerlink" title="1.一级缓存(本地缓存)"></a>1.一级缓存(本地缓存)</h2><a id="more"></a>
<h3 id="1-使用"><a href="#1-使用" class="headerlink" title="*1.使用"></a>*1.使用</h3><p>sqlSession级别的缓存(一个Map)，一级缓存一直开启，与数据库同一次会话期间查询到的数据会放在本地缓存中，以后如果需要获取相同的数据，直接从缓存中取</p>
<h3 id="2-失效情况"><a href="#2-失效情况" class="headerlink" title="*2.失效情况"></a>*2.失效情况</h3><ul>
<li>sqlSession不同</li>
<li>sqlSession相同，查询条件不同(一级缓存中还没有这个数据)</li>
<li>sqlSession相同，两次查询之间执行了增删改的操作</li>
<li>sqlSession相同，手动清除了一级缓存</li>
</ul>
<hr>
<h2 id="2-二级缓存-全局缓存"><a href="#2-二级缓存-全局缓存" class="headerlink" title="2.二级缓存(全局缓存)"></a>2.二级缓存(全局缓存)</h2><p>基于namespace级别的缓存，一个namespace对应一个二级缓存</p>
<h3 id="1-工作机制"><a href="#1-工作机制" class="headerlink" title="*1. 工作机制"></a>*1. 工作机制</h3><ul>
<li>一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中。如果<strong>会话关闭</strong>，一级缓存中的数据会被保存到二级缓存中，新的会话查询信息，就可以参照二级缓存</li>
<li>不同namespace查出的数据会放在自己对应的缓存中(map)<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="*2. 使用"></a>*2. 使用</h3><h4 id="1-开启全局二级缓存"><a href="#1-开启全局二级缓存" class="headerlink" title="**1. 开启全局二级缓存"></a>**1. 开启全局二级缓存</h4><h4 id="2-mapper-xml中配置使用二级缓存"><a href="#2-mapper-xml中配置使用二级缓存" class="headerlink" title="**2. mapper.xml中配置使用二级缓存"></a>**2. mapper.xml中配置使用二级缓存</h4>对应的mapper会有二级缓存<br><img src="\cttImages\1548472648617.png" alt="1548472648617"><h4 id="3-实体类要实现序列化接口"><a href="#3-实体类要实现序列化接口" class="headerlink" title="**3.实体类要实现序列化接口"></a>**3.实体类要实现序列化接口</h4><ul>
<li>eviction(回收策略)<ul>
<li>LRU(默认) 移除最长时间不使用的对象</li>
<li>FIFO 按对象进入缓存的顺序来移除</li>
<li>SOFT 软引用，基于垃圾回收器状态和软引用规则移除对象</li>
<li>WEAK 弱引用，基于垃圾回收器状态和软引用规则移除对象，更积极</li>
</ul>
</li>
<li>flushInterval(缓存刷新间隔):缓存多长时间清空一次，默认不清空，设置一个毫秒值</li>
<li>readOnly(是否只读)：<ul>
<li>true：mybatis认为所有从缓存中获取数据的操作都是只读，会直接把对对象的引用交给用户</li>
<li>false： mybatis认为获取数据可能会被修改，利用序列化反序列克隆一份新数据给用户</li>
</ul>
</li>
<li>size(存放多少元素)</li>
<li>type(指定自定义缓存全类名)，实现Cache接口即可<h2 id="3-缓存的相关配置"><a href="#3-缓存的相关配置" class="headerlink" title="3.缓存的相关配置"></a>3.缓存的相关配置</h2><img src="\cttImages\1548473336719.png" alt="1548473336719"><br>注：cacheEnable 是在全局mapper配置setting中的属性<h2 id="4-整合第三方缓存"><a href="#4-整合第三方缓存" class="headerlink" title="4.整合第三方缓存"></a>4.整合第三方缓存</h2>mybatis自带有一二级缓存，并且提供了Cache接口，供用户使用第三方缓存，如ehCache、redisCache</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>后台方向</category>
        <category>后台框架</category>
        <category>ssm</category>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 关联GitHub搭建自己的博客</title>
    <url>/2019/01/23/Hexo-%E5%85%B3%E8%81%94GitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Hexo-关联GitHub搭建自己的博客"><a href="#Hexo-关联GitHub搭建自己的博客" class="headerlink" title="Hexo 关联GitHub搭建自己的博客"></a>Hexo 关联GitHub搭建自己的博客</h1><h2 id="一-安装步骤"><a href="#一-安装步骤" class="headerlink" title="一.安装步骤"></a>一.安装步骤</h2><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">Hexo安装+GitHub关联+设置个人域名</a></p>
<ul>
<li>注: 1. GitHub中的GitPage必须是public仓库<h2 id="二-使用"><a href="#二-使用" class="headerlink" title="二.使用"></a>二.使用</h2><a id="more"></a>
<h3 id="1-添加文章："><a href="#1-添加文章：" class="headerlink" title="1.添加文章："></a>1.添加文章：</h3></li>
<li>hexo new “context_name” 创建一个发布上去的文章</li>
<li>hexo new draft “context_name” 创建一个草稿<br>运行时，草稿中的文章是不会出现，要预览草稿中的文章，要通过 hexo server –draft启动<br>发布草稿，hexo publish b，从draft转移到post中</li>
<li>hexo new page “page_name”<br>对应一个页面，可以填写type属性(可自定义，也可以用已有的页面 如:/about,/tags)<h3 id="2-删除文章："><a href="#2-删除文章：" class="headerlink" title="2.删除文章："></a>2.删除文章：</h3></li>
<li>直接在本地source文件夹中删除对应文章即可<h3 id="3-基本命令："><a href="#3-基本命令：" class="headerlink" title="3.基本命令："></a>3.基本命令：</h3></li>
<li>hexo generate 用于生成静态文件</li>
<li>hexo server 用于启动服务器</li>
<li>hexo clean 用于清楚之前生成的东西(可不加)</li>
<li>hexo g 用于生成静态文章</li>
<li>hexo d 用于本地文件发布到github中<h2 id="三-主题"><a href="#三-主题" class="headerlink" title="三.主题"></a>三.主题</h2><h3 id="1-next主题"><a href="#1-next主题" class="headerlink" title="1.next主题"></a>1.next主题</h3><a href="http://theme-next.iissnan.com/getting-started.html#menu-settings" target="_blank" rel="noopener">next 官方文档</a><br><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">简书中 next主题的设置</a><h2 id="四-常用设置"><a href="#四-常用设置" class="headerlink" title="四.常用设置"></a>四.常用设置</h2><h3 id="1-阅读全文按钮"><a href="#1-阅读全文按钮" class="headerlink" title="1.阅读全文按钮"></a>1.阅读全文按钮</h3>！–more–   两边要有&lt;  &gt;<h3 id="2-设置多个标签-子主题"><a href="#2-设置多个标签-子主题" class="headerlink" title="2. 设置多个标签 子主题"></a>2. 设置多个标签 子主题</h3><a href="https://www.jianshu.com/p/e17711e44e00" target="_blank" rel="noopener">参考本文的设置方式</a><h3 id="3-博客加密"><a href="#3-博客加密" class="headerlink" title="3.博客加密"></a>3.博客加密</h3><a href="https://www.jianshu.com/p/a2330937de6c" target="_blank" rel="noopener">简单加密的方式</a><br><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md" target="_blank" rel="noopener">插件加密文档</a></li>
</ul>
]]></content>
      <categories>
        <category>小工具</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Computer</tag>
        <tag>Study</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
